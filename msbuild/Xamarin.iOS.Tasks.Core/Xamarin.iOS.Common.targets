<!--
***********************************************************************************************
Xamarin.iOS.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
  created a backup copy.  Incorrect changes to this file will make it
  impossible to load or build your projects from the command-line or the IDE.

This file imports the version- and platform-specific targets for the project importing
this file. This file also defines targets to produce an error if the specified targets
file does not exist, but the project is built anyway (command-line or IDE build).

Copyright (C) 2013-2016 Xamarin. All rights reserved.
***********************************************************************************************
-->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ArTool" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.Codesign" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CollectBundleResources" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ComputeBundleResourceOutputPaths" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CoreMLCompiler" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CreateAssetPackManifest" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CreatePkgInfo" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.Ditto" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.DSymUtil" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.FindItemWithLogicalName" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.GenerateBundleName" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.GetNativeExecutableName" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.GetPropertyListValue" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.PackLibraryResources" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.PropertyListEditor" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ReadItemsFromFile" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.SmartCopy" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.SpotlightIndexer" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.SymbolStrip" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.UnpackLibraryResources" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.WriteItemsToFile" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.Zip" AssemblyFile="Xamarin.iOS.Tasks.dll" />

	<UsingTask TaskName="Xamarin.iOS.Tasks.ALToolValidate" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.ALToolUpload" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.ACTool" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.Archive" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CodesignNativeLibraries" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CodesignVerify" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CollectAssetPacks" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CollectFrameworks" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CollectITunesArtwork" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CollectITunesSourceFiles" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CompileAppManifest" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CompileEntitlements" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CompileITunesMetadata" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CompileSceneKitAssets" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CreateAssetPack" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CreateDebugSettings" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.CreateDebugConfiguration" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.DetectDebugNetworkConfiguration" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.DetectSdkLocations" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.DetectSigningIdentity" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.EmbedMobileProvision" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.FindWatchOS1AppExtensionBundle" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.FindWatchOS2AppBundle" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.GetDirectories" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.GetFiles" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.GetFullPath" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.IBTool" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.MetalLib" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.Metal" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.MTouch" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.OptimizeImage" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.OptimizePropertyList" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.ParseDeviceSpecificBuildInformation" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.ParseExtraMtouchArgs" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.PrepareResourceRules" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.ScnTool" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.TextureAtlas" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.ValidateAppBundleTask" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.WriteAssetPackManifest" AssemblyFile="Xamarin.iOS.Tasks.dll" />

	<UsingTask TaskName="Microsoft.Build.Tasks.Copy" AssemblyFile="Xamarin.iOS.Tasks.dll"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.Delete" AssemblyFile="Xamarin.iOS.Tasks.dll"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.Exec" AssemblyFile="Xamarin.iOS.Tasks.dll"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.MakeDir" AssemblyFile="Xamarin.iOS.Tasks.dll"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.Move" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir" AssemblyFile="Xamarin.iOS.Tasks.dll"/>
	<UsingTask TaskName="Microsoft.Build.Tasks.Touch" AssemblyFile="Xamarin.iOS.Tasks.dll"/>

	<Import Project="$(MSBuildThisFileDirectory)Xamarin.iOS.Common.props" 
			Condition="'$(_XamarinCommonPropsHasBeenImported)' != 'true'" />

	<Import Project="$(MSBuildThisFileDirectory)$(MSBuildThisFileName).Before.targets" 
			Condition="Exists('$(MSBuildThisFileDirectory)$(MSBuildThisFileName).Before.targets')"/>

	<!-- *** Code Analysis Setup *** -->
	<!-- Library projects aren't supported, if we enable Xamarin.Analysis on them, we'll need to revisit the rules and deactivate some (e.g XIA0002). -->

	<PropertyGroup>
		<!-- '$(OutputType)' == 'Exe' because we don't want to run Xamarin.Analysis on library projects, the XIA rules don't apply. -->
		<XamarinAnalysisTargetsFile Condition="Exists ('$(MSBuildThisFileDirectory)Xamarin.iOS.Analysis.targets') And '$(OutputType)' == 'Exe'">$(MSBuildThisFileDirectory)Xamarin.iOS.Analysis.targets</XamarinAnalysisTargetsFile>
	</PropertyGroup>

	<Import Project="$(MSBuildThisFileDirectory)Xamarin.Analysis.targets"
			Condition="Exists('$(MSBuildThisFileDirectory)Xamarin.Analysis.targets') And '$(OutputType)' == 'Exe'" />

	<Import Project="$(MSBuildThisFileDirectory)Xamarin.Shared.targets" />			

	<PropertyGroup>
		<!-- Switching to a new property allows us to potentially switch from iPhone to simulator builds
			 dynamically based on the user's selection when starting the project. This allows us to 
			 eventually even (optionally) switch back to AnyCPU platform in the IDE, therefore 
			 fixing a key pain point in managing solution configurations. -->
		<ComputedPlatform Condition="'$(ComputedPlatform)' == ''">$(Platform)</ComputedPlatform>
		<ComputedPlatform Condition="'$(ComputedPlatform)' == 'AnyCPU'">iPhone</ComputedPlatform>

		<_CanOutputAppBundle>False</_CanOutputAppBundle>
		<_CanOutputAppBundle Condition="'$(OutputType)' == 'Exe' Or '$(IsAppExtension)' == 'true' Or '$(IsWatchApp)' == 'true'">True</_CanOutputAppBundle>

		<_CanArchive>False</_CanArchive>
		<_CanArchive Condition="'$(OutputType)' == 'Exe' And '$(ComputedPlatform)' == 'iPhone' And '$(IsAppExtension)' == 'false' And '$(IsWatchApp)' == 'false'">True</_CanArchive>

		<_CanDeployToDeviceOrSimulator>False</_CanDeployToDeviceOrSimulator>
		<_CanDeployToDeviceOrSimulator Condition="('$(OutputType)' == 'Exe' Or '$(IsAppExtension)' == 'true') And '$(IsWatchApp)' == 'false'">True</_CanDeployToDeviceOrSimulator>

		<_RequireCodeSigning>False</_RequireCodeSigning>
		<_RequireCodeSigning Condition="'$(ComputedPlatform)' == 'iPhone'">True</_RequireCodeSigning>

		<_RequireProvisioningProfile>False</_RequireProvisioningProfile>
		<_RequireProvisioningProfile Condition="'$(ComputedPlatform)' == 'iPhone' Or '$(CodesignEntitlements)' != ''">True</_RequireProvisioningProfile>

		<_PreparedResourceRules></_PreparedResourceRules>
		<_AppBundleName>$(AssemblyName)</_AppBundleName>

		<AppBundleExtension Condition="'$(AppBundleExtension)' == ''">.app</AppBundleExtension>

		<DeviceSpecificIntermediateOutputPath>$(IntermediateOutputPath)</DeviceSpecificIntermediateOutputPath>
		<DeviceSpecificOutputPath>$(OutputPath)</DeviceSpecificOutputPath>
	</PropertyGroup>
	
	<PropertyGroup>
		<ImplicitlyExpandDesignTimeFacades>true</ImplicitlyExpandDesignTimeFacades>
		<CheckForSystemRuntimeDependency>true</CheckForSystemRuntimeDependency>

		<ResolveReferencesDependsOn>
			_SeparateAppExtensionReferences;
			_SeparateWatchAppReferences;
			$(ResolveReferencesDependsOn);
			ImplicitlyExpandDesignTimeFacades
		</ResolveReferencesDependsOn>

		<ImplicitlyExpandDesignTimeFacadesDependsOn>
			$(ImplicitlyExpandDesignTimeFacadesDependsOn);
			GetReferenceAssemblyPaths
		</ImplicitlyExpandDesignTimeFacadesDependsOn>
	</PropertyGroup>

	<ItemDefinitionGroup>
		<!-- MSBuild will honor this default metadata, but xbuild will not, so we still need to use CreateItem -->
		<_BundleResourceWithLogicalName>
			<Optimize />
		</_BundleResourceWithLogicalName>
	</ItemDefinitionGroup>

	<UsingTask
		TaskName="GetDependsOnNETStandard"
		AssemblyFile="$(MicrosoftNETBuildExtensionsTasksAssembly)" />

	<Target Name="ImplicitlyExpandDesignTimeFacades" Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'" DependsOnTargets="$(ImplicitlyExpandDesignTimeFacadesDependsOn)">
		<ItemGroup>
			<XI_CandidateNETStandardReferences Include="@(Reference);@(_ResolvedProjectReferencePaths)" />
			<XI_InboxNETStandardFolders Include="$(TargetFrameworkDirectory)" />
		</ItemGroup>

		<PropertyGroup>
			<_HasReferenceToSystemRuntime Condition="'$(DependsOnSystemRuntime)' == 'true' or '%(_ResolvedProjectReferencePaths.TargetPlatformIdentifier)' == 'Portable' 
								or '%(ReferenceDependencyPaths.Filename)' == 'System.Runtime'">true</_HasReferenceToSystemRuntime>

			<XI_NETStandardInbox Condition="'$(XI_NETStandardInbox)' == '' and Exists('%(XI_InboxNETStandardFolders.Identity)\netstandard.dll')">true</XI_NETStandardInbox>

			<!--
				This is `true` if any of the references depends on `netstandard`.

				In cases where `ResolveAssemblyReference` task does get run, it populates `$(_DependsOnNETStandard)` property, so we don't
				need to check this again.
			-->
			<XI_DependsOnNETStandard Condition="'$(XI_DependsOnNETStandard)' == ''">$(_DependsOnNETStandard)</XI_DependsOnNETStandard>
		</PropertyGroup>

		<!--
		     Facades are expanded if we have a reference that depends on System.Runtime .

		     XI projects have `$(TargetFrameworkIdentifier) != .NETFramework`, so Microsoft.NET.Build.Extensions (which provides support for ns 2.0 projects) doesn't get
		     imported. And netstandard.dll reference, even if required, doesn't get added.

		     So, we need to check if any references depend on `netstandard`. And if so, expand the facades, which include netstandard.dll .

		     If $(_HasReferenceToSystemRuntime) is true, then the facades are going to be expanded anyway, so don't run this.
		-->
		<GetDependsOnNETStandard
			Condition="'$(_HasReferenceToSystemRuntime)' != 'true' and '$(XI_DependsOnNETStandard)' == '' and '@(XI_CandidateNETStandardReferences)' != ''"
			References="@(XI_CandidateNETStandardReferences)">
			<Output TaskParameter="DependsOnNETStandard" PropertyName="XI_DependsOnNETStandard" />
		</GetDependsOnNETStandard>

		<ItemGroup Condition="'$(_HasReferenceToSystemRuntime)' == 'true' or ('$(XI_NETStandardInbox)' == 'true' and '$(XI_DependsOnNETStandard)' == 'true')">
			<_DesignTimeFacadeAssemblies Include="%(DesignTimeFacadeDirectories.Identity)*.dll"/>
			<ReferencePath Remove="@(_DesignTimeFacadeAssemblies)"/>
			<ReferencePath Include="%(_DesignTimeFacadeAssemblies.Identity)">
				<WinMDFile>false</WinMDFile>
				<CopyLocal>false</CopyLocal>
				<ResolvedFrom>ImplicitlyExpandDesignTimeFacades</ResolvedFrom>
			</ReferencePath>
			<ReferenceDependencyPath Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
		</ItemGroup>

		<Message Importance="Low" Text="Including @(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
	</Target>

	<Target Name="_ComputeTargetArchitectures">
		<ParseDeviceSpecificBuildInformation
			SessionId="$(BuildSessionId)"
			Condition="'$(DeviceSpecificBuild)' == 'true' And '$(TargetiOSDevice)' != '' And '$(_CanDeployToDeviceOrSimulator)' == 'true'"
			Architectures="$(MtouchArch)"
			IntermediateOutputPath="$(IntermediateOutputPath)"
			OutputPath="$(OutputPath)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			TargetiOSDevice="$(TargetiOSDevice)"
		>
			<Output TaskParameter="DeviceSpecificIntermediateOutputPath" PropertyName="DeviceSpecificIntermediateOutputPath" />
			<Output TaskParameter="DeviceSpecificOutputPath" PropertyName="DeviceSpecificOutputPath" />
			<Output TaskParameter="TargetArchitectures" PropertyName="TargetArchitectures" />
			<Output TaskParameter="TargetDeviceModel" PropertyName="TargetDeviceModel" />
			<Output TaskParameter="TargetDeviceOSVersion" PropertyName="TargetDeviceOSVersion" />
		</ParseDeviceSpecificBuildInformation>

		<PropertyGroup>
			<_MtouchSymbolsList>$(DeviceSpecificIntermediateOutputPath)mtouch-symbols.list</_MtouchSymbolsList>

			<!-- actool output caches -->
			<_ACTool_PartialAppManifestCache>$(DeviceSpecificIntermediateOutputPath)actool\_PartialAppManifest.items</_ACTool_PartialAppManifestCache>
			<_ACTool_BundleResourceCache>$(DeviceSpecificIntermediateOutputPath)actool\_BundleResourceWithLogicalName.items</_ACTool_BundleResourceCache>

			<!-- coremlc output caches -->
			<_CoreMLModel_PartialAppManifestCache>$(DeviceSpecificIntermediateOutputPath)coremlc\_PartialAppManifest.items</_CoreMLModel_PartialAppManifestCache>
			<_CoreMLModel_BundleResourceCache>$(DeviceSpecificIntermediateOutputPath)coremlc\_BundleResourceWithLogicalName.items</_CoreMLModel_BundleResourceCache>

			<!-- ibtool output caches -->
			<_IBToolCache>$(DeviceSpecificIntermediateOutputPath)ibtool\_BundleResourceWithLogicalName.items</_IBToolCache>

			<!-- scntool output caches -->
			<_SceneKitCache>$(DeviceSpecificIntermediateOutputPath)copySceneKitAssets\_BundleResourceWithLogicalName.items</_SceneKitCache>

			<!-- TextureAtlas output caches -->
			<_TextureAtlasCache>$(DeviceSpecificIntermediateOutputPath)atlas\_BundleResourceWithLogicalName.items</_TextureAtlasCache>
		</PropertyGroup>
	</Target>

	<!-- Insert our app bundle generation step -->
	<PropertyGroup>
		<BuildDependsOn>
			BuildOnlySettings;
			PrepareForBuild;
			_CollectBundleResources;
			_OptimizePngImages;
			_OptimizePropertyLists;
			_OptimizeLocalizationFiles;
			_PackLibraryResources;
			_UnpackLibraryResources;
			$(BuildDependsOn);
			_GenerateBundleName;
			_CleanUploaded;
			_CreateAppBundle;
			Codesign;
			CreateIpa;
			Archive;
		</BuildDependsOn>

		<CleanDependsOn>
			$(CleanDependsOn);
			_ComputeTargetArchitectures;
			_CleanUploaded;
			_CleanAppBundle;
			_CleanDebugSymbols;
			_CleanITunesArtwork;
			_CleanDeviceSpecificOutput;
			_CleanIntermediateToolOutput;
		</CleanDependsOn>
	</PropertyGroup>

	<PropertyGroup>
		<CompileColladaAssetsDependsOn>
			_CollectColladaAssets;
			_CoreCompileColladaAssets
		</CompileColladaAssetsDependsOn>
	</PropertyGroup>

	<PropertyGroup>
		<_IsContainerApp>false</_IsContainerApp>
		<_IsContainerApp Condition="$(IsAppExtension) == 'false' And '$(IsWatchApp)' == 'false'">true</_IsContainerApp>
	</PropertyGroup>

	<Target Name="_CompileColladaAssets" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="$(CompileColladaAssetsDependsOn)" />

	<PropertyGroup>
		<OptimizePngImagesDependsOn>
			_CollectPngImages;
			_CoreOptimizePngImages;
			_AfterCoreOptimizePngImages
		</OptimizePngImagesDependsOn>
	</PropertyGroup>

	<Target Name="_OptimizePngImages" DependsOnTargets="$(OptimizePngImagesDependsOn)" />

	<PropertyGroup>
		<OptimizePropertyListsDependsOn>
			_CollectPropertyLists;
			_CoreOptimizePropertyLists;
			_AfterCoreOptimizePropertyLists
		</OptimizePropertyListsDependsOn>
	</PropertyGroup>

	<Target Name="_OptimizePropertyLists" DependsOnTargets="$(OptimizePropertyListsDependsOn)" />

	<PropertyGroup>
		<OptimizeLocalizationFilesDependsOn>
			_CollectLocalizationFiles;
			_CoreOptimizeLocalizationFiles;
			_AfterCoreOptimizeLocalizationFiles
		</OptimizeLocalizationFilesDependsOn>
	</PropertyGroup>

	<Target Name="_OptimizeLocalizationFiles" DependsOnTargets="$(OptimizeLocalizationFilesDependsOn)" />

	<PropertyGroup>
		<CreateAppBundleDependsOn>
			_DetectAppManifest;
			_DetectSigningIdentity;
			_CopyResourcesToBundle;
			_CreateAssetPackManifest;
			_SmeltMetal;
			_ForgeMetal;
			_TemperMetal;
			_CompileCoreMLModels;
			_PrepareResourceRules;
			_CompileEntitlements;
			_CompileAppManifest;
			_GetNativeExecutableName;
			_ParseExtraMtouchArgs;
			_CompileToNative;
			_CompileITunesMetadata;
			_CollectITunesArtwork;
			_CopyITunesArtwork;
			_CreateDebugSettings;
			_CreateDebugConfiguration;
			_CreatePkgInfo;
			_CopyAppExtensionsToBundle;
			_CopyWatchOS1AppsToBundle;
			_CopyWatchOS2AppsToBundle;
			_ReadAppExtensionDebugSymbolProperties;
			_GenerateAppExtensionDebugSymbols;
			_PrepareDebugSymbolGeneration;
			_GenerateDebugSymbols;
			_ValidateAppBundle;
		</CreateAppBundleDependsOn>
	</PropertyGroup>

	<Target Name="_CreateAppBundle" Condition="'$(_CanOutputAppBundle)' == 'true' And '$(IsAppDistribution)' != 'true'" DependsOnTargets="$(CreateAppBundleDependsOn)" />

	<PropertyGroup>
		<_CodesignAppBundleDependsOn>
			_EmbedMobileProvision;
			_CodesignNativeLibraries;
			_CollectFrameworks;
			_CodesignFrameworks;
			_ReadAppExtensionCodesignProperties;
			_CodesignAppExtensions;
			_PrepareCodesignAppExtension;
			_CalculateCodesignAppBundleInputs;
		</_CodesignAppBundleDependsOn>

		<_CoreCodesignDependsOn>
			$(_CodesignAppBundleDependsOn);
			_CodesignAppBundle;
			_CodesignVerify;
		</_CoreCodesignDependsOn>

		<CodesignDependsOn>
			BeforeCodeSign;
			CoreCodeSign;
			AfterCodeSign;
		</CodesignDependsOn>
	</PropertyGroup>

	<Target Name="BeforeCodesign" />
	<Target Name="CoreCodesign" DependsOnTargets="$(_CoreCodesignDependsOn)" />
	<Target Name="AfterCodesign" />

	<Target Name="Codesign" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_CreateAppBundle;$(CodesignDependsOn)" />

	<PropertyGroup>
		<!-- Extensibility point for VS Publishing Workflow -->
		<_BeforeCreateIpaForDistributionDependsOn />
		
		<CreateIpaDependsOn>
			_BeforeCreateIpaForDistribution;
			_CompileEntitlements;
			_CoreCreateIpa;
			_PackageOnDemandResources;
			_ZipIpa
		</CreateIpaDependsOn>

		<ArchiveDependsOn>
			_CoreArchive
		</ArchiveDependsOn>
	</PropertyGroup>

	<Target Name="ValidateAppStoreBundle" DependsOnTargets="_DetectSdkLocations">
		<ALToolValidate
			SessionId="$(BuildSessionId)"
			Username="$(Username)"
			Password="$(Password)"
			FilePath="$(FilePath)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			SdkDevPath="$(_SdkDevPath)"
		/>
	</Target>

	<Target Name="UploadAppStoreBundle" DependsOnTargets="_DetectSdkLocations">
		<ALToolUpload
			SessionId="$(BuildSessionId)"
			Username="$(Username)"
			Password="$(Password)"
			FilePath="$(FilePath)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			SdkDevPath="$(_SdkDevPath)"
		/>
	</Target>

	<Target Name="Archive" Condition="'$(_CanArchive)' == 'true'" DependsOnTargets="$(ArchiveDependsOn)" />

	<Target Name="_BeforeCreateIpaForDistribution" Condition="'$(IsAppDistribution)' == 'true'" DependsOnTargets="$(_BeforeCreateIpaForDistributionDependsOn)" />
	
	<Target Name="CreateIpa" Condition="'$(_CanArchive)' == 'true'" DependsOnTargets="$(CreateIpaDependsOn)" />

	<Target Name="_CleanAppBundle" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_GenerateBundleName">
		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(_AppBundlePath)" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="$(DeviceSpecificOutputPath)mtouch.stamp" />
	</Target>

	<Target Name="_CleanUploaded" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_ComputeTargetArchitectures">
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="$(DeviceSpecificOutputPath).uploaded" />
	</Target>

	<Target Name="_CleanDebugSymbols" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_GenerateBundleName">
		<GetDirectories SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Path="$(DeviceSpecificOutputPath)" Pattern="*.dSYM">
			<Output TaskParameter="Directories" ItemName="_DebugSymbolDir" />
		</GetDirectories>

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(AppBundleDir).mSYM;@(_DebugSymbolDir)" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'false'" Files="$(DeviceSpecificOutputPath)*.bcsymbolmap" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'true'" Files="$(DeviceSpecificOutputPath)dsym.items" />
	</Target>

	<Target Name="_CleanITunesArtwork" Condition="'$(_CanArchive)' == 'true'" DependsOnTargets="_ComputeTargetArchitectures">
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="$(DeviceSpecificOutputPath)iTunesMetadata.plist;$(DeviceSpecificOutputPath)iTunesArtwork@2x;$(DeviceSpecificOutputPath)iTunesArtwork" />
	</Target>

	<Target Name="_CleanDeviceSpecificOutput" Condition="'$(_CanOutputAppBundle)' == 'true'">
		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(IntermediateOutputPath)device-builds;$(OutputPath)device-builds" />
	</Target>

	<Target Name="_CleanIntermediateToolOutput" DependsOnTargets="_ComputeTargetArchitectures">
		<RemoveDir SessionId="$(BuildSessionId)" 
			Condition="'$(IsMacEnabled)' == 'true'" 
			Directories="$(DeviceSpecificIntermediateOutputPath)actool;
					$(DeviceSpecificIntermediateOutputPath)assetpacks;
					$(DeviceSpecificIntermediateOutputPath)codesign;
					$(DeviceSpecificIntermediateOutputPath)coremlc;
					$(DeviceSpecificIntermediateOutputPath)ibtool;
					$(DeviceSpecificIntermediateOutputPath)ibtool-link;
					$(DeviceSpecificIntermediateOutputPath)ibtool-manifests;
					$(DeviceSpecificIntermediateOutputPath)ipa;
					$(DeviceSpecificIntermediateOutputPath)metal;
					$(DeviceSpecificIntermediateOutputPath)optimized;
					$(DeviceSpecificIntermediateOutputPath)scntool;
					$(DeviceSpecificIntermediateOutputPath)TextureAtlas;
					$(DeviceSpecificIntermediateOutputPath)mtouch-cache;
					$(DeviceSpecificIntermediateOutputPath)" />

		<ItemGroup>
			<_IpaPackageFile Include="$(DeviceSpecificOutputPath)*.ipa" />
		</ItemGroup>

		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'true'" Files="$(DeviceSpecificOutputPath)codesign.items" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="@(_IpaPackageFile)" />
	</Target>

	<Target Name="_AddExtraReferences" BeforeTargets="ResolveAssemblyReferences" Condition="'$(DisableExtraReferences)' != 'true'">
		<ItemGroup>
			<!-- https://github.com/mono/mono/issues/13483 -->
			<Reference Include="System.Drawing.Common.dll" />
		</ItemGroup>
	</Target>

	<PropertyGroup>
		<_CollectBundleResourcesDependsOn>
			_CompileInterfaceDefinitions;
			_CompileImageAssets;
			_CompileColladaAssets;
			_CompileSceneKitAssets;
			_CompileTextureAtlases;
			_CompileCoreMLModels;
		</_CollectBundleResourcesDependsOn>
	</PropertyGroup>

	<!-- TODO: check for duplicate items -->
	<Target Name="_ComputeBundleResourceOutputPaths" DependsOnTargets="_CollectBundleResources;_GenerateBundleName;_DetectSigningIdentity">
		<ComputeBundleResourceOutputPaths
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			BundleIdentifier="$(_BundleIdentifier)"
			BundleResources="@(_BundleResourceWithLogicalName)"
			EnableOnDemandResources="$(EnableOnDemandResources)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			OutputPath="$(DeviceSpecificOutputPath)"
		>
			<Output TaskParameter="BundleResourcesWithOutputPaths" ItemName="_BundleResourceWithOutputPath"/>
		</ComputeBundleResourceOutputPaths>
	</Target>

	<Target Name="_CopyResourcesToBundle" DependsOnTargets="_ComputeBundleResourceOutputPaths"
		Inputs = "@(_BundleResourceWithOutputPath)"
		Outputs = "@(_BundleResourceWithOutputPath -> '%(OutputPath)')" >
		<SmartCopy
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			SourceFiles = "@(_BundleResourceWithOutputPath)"
			DestinationFiles = "@(_BundleResourceWithOutputPath -> '%(OutputPath)')"
		/>
	</Target>

	<Target Name="_CreateAssetPackManifest" DependsOnTargets="_CopyResourcesToBundle">
		<CreateAssetPackManifest
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			InitialInstallTags="$(OnDemandResourcesInitialInstallTags)"
			PrefetchOrder="$(OnDemandResourcesPrefetchOrder)"
			OutputPath="$(DeviceSpecificOutputPath)"
		/>
	</Target>

	<Target Name="_CollectBundleResources" DependsOnTargets="$(_CollectBundleResourcesDependsOn)">
		<CollectBundleResources
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			OptimizePropertyLists="$(OptimizePropertyLists)"
			OptimizePNGs="$(OptimizePNGs)"
			BundleResources="@(Content);@(BundleResource)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			>

			<Output TaskParameter="BundleResourcesWithLogicalNames" ItemName="_BundleResourceWithLogicalName"/>
		</CollectBundleResources>
	</Target>

	<Target Name="_DetectAppManifest">
		<FindItemWithLogicalName
			SessionId="$(BuildSessionId)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			LogicalName="Info.plist"
			Items="@(None)">
			<Output TaskParameter="Item" PropertyName="_AppManifest" />
		</FindItemWithLogicalName>
		<FindItemWithLogicalName Condition="'$(_AppManifest)' == '' And '$(_CanOutputAppBundle)' == 'true'"
			SessionId="$(BuildSessionId)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			LogicalName="Info.plist"
			Items="@(BundleResource)">
			<Output TaskParameter="Item" PropertyName="_AppManifest" />
		</FindItemWithLogicalName>
		<FindItemWithLogicalName Condition="'$(_AppManifest)' == '' And '$(_CanOutputAppBundle)' == 'true'"
			SessionId="$(BuildSessionId)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			LogicalName="Info.plist"
			Items="@(Content)">
			<Output TaskParameter="Item" PropertyName="_AppManifest" />
		</FindItemWithLogicalName>
		<Error Condition="'$(_AppManifest)' == '' And '$(_CanOutputAppBundle)' == 'true'" Text="Info.plist not found."/>
	</Target>

	<Target Name="_SmeltMetal" Condition="'$(_CanOutputAppBundle)' == 'true' And '@(Metal)' != ''" DependsOnTargets="_DetectSdkLocations">
		<Error Condition="'$(ComputedPlatform)' == 'iPhoneSimulator'" Text="The iOS Simulator does not support metal. Build for a device instead."/>

		<Metal
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' and '%(Metal.Identity)' != ''"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			AppManifest="$(_AppManifest)"
			ProjectDir="$(MSBuildProjectDirectory)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)"
			SdkRoot="$(_SdkRoot)"
			SdkVersion="$(MtouchSdkVersion)"
			SourceFile="@(Metal)">
			<Output TaskParameter="OutputFile" ItemName="_SmeltedMetal" />
		</Metal>
	</Target>

	<Target Name="_ForgeMetal" Condition="'$(_CanOutputAppBundle)' == 'true' And '@(_SmeltedMetal)' != ''" DependsOnTargets="_SmeltMetal"
		Inputs="@(_SmeltedMetal)" Outputs="$(DeviceSpeficicIntermediateOutputPath)metal\default.metal-ar">
		<ArTool
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' and '$(_IsXcode8)' == 'false'"
			Items="@(_SmeltedMetal)"
			Archive="$(DeviceSpecificIntermediateOutputPath)metal\default.metal-ar">
		</ArTool>

		<!-- If !Xcode8 -->
		<CreateItem Include="$(DeviceSpecificIntermediateOutputPath)metal\default.metal-ar"
					Condition="'$(_IsXcode8)' == 'false'">
			<Output TaskParameter="Include" ItemName="_ForgedMetal" />
		</CreateItem>

		<!-- Else -->
		<CreateItem Include="@(_SmeltedMetal)"
					Condition="'$(_IsXcode8)' == 'true'">
			<Output TaskParameter="Include" ItemName="_ForgedMetal" />
		</CreateItem>
	</Target>

	<Target Name="_TemperMetal" Condition="'$(_CanOutputAppBundle)' == 'true' And '@(_ForgedMetal)' != ''" DependsOnTargets="_ForgeMetal"
		Inputs="@(_ForgedMetal)" Outputs="$(_AppBundlePath)default.metallib">
		<MetalLib
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			Items="@(_ForgedMetal)"
			SdkDevPath="$(_SdkDevPath)"
			SdkRoot="$(_SdkRoot)"
			OutputLibrary="$(_AppBundlePath)default.metallib">
		</MetalLib>
	</Target>

	<Target Name="_PackLibraryResources" Condition="'$(_CanOutputAppBundle)' == 'false'" DependsOnTargets="_CollectBundleResources">
		<PackLibraryResources
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			Prefix="monotouch"
			BundleResourcesWithLogicalNames="@(_BundleResourceWithLogicalName)">
			<Output TaskParameter="EmbeddedResources" ItemName="EmbeddedResource" />
		</PackLibraryResources>
	</Target>

	<Target Name="_UnpackLibraryResources" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="ResolveReferences;_CollectBundleResources">
		<UnpackLibraryResources
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			Prefix="monotouch"
			NoOverwrite="@(_BundleResourceWithLogicalName)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			TargetFrameworkDirectory="$(TargetFrameworkDirectory)"
			ReferencedLibraries="@(ReferencePath);@(ReferenceDependencyPaths)">
			<Output TaskParameter="BundleResourcesWithLogicalNames" ItemName="_BundleResourceWithLogicalName" />
		</UnpackLibraryResources>
	</Target>

	<Target Name="_DetectSdkLocations" DependsOnTargets="_ComputeTargetArchitectures">
		<DetectSdkLocations
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			SdkVersion="$(MtouchSdkVersion)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			TargetArchitectures="$(TargetArchitectures)"
			>
			
			<Output TaskParameter="SdkVersion" PropertyName="MtouchSdkVersion" />
			<Output TaskParameter="SdkRoot" PropertyName="_SdkRoot" />
			<Output TaskParameter="SdkBinPath" PropertyName="_SdkBinPath" />
			<Output TaskParameter="SdkDevPath" PropertyName="_SdkDevPath" />
			<Output TaskParameter="SdkUsrPath" PropertyName="_SdkUsrPath" />
			<Output TaskParameter="SdkPlatform" PropertyName="_SdkPlatform" />
			<Output TaskParameter="SdkIsSimulator" PropertyName="_SdkIsSimulator" />
			<Output TaskParameter="IsXcode8" PropertyName="_IsXcode8" />
		</DetectSdkLocations>
	</Target>

	<Target Name="_DetectSigningIdentity" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_DetectAppManifest;_DetectSdkLocations">
		<DetectSigningIdentity
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleName="$(_AppBundleName)"
			AppManifest="$(_AppManifest)"
			Keychain="$(CodesignKeychain)"
			RequireCodeSigning="$(_RequireCodeSigning)"
			RequireProvisioningProfile="$(_RequireProvisioningProfile)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkPlatform="$(_SdkPlatform)"
			ProvisioningProfile="$(CodesignProvision)"
			SigningKey="$(CodesignKey)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			>

			<Output TaskParameter="DetectedAppId" PropertyName="_AppIdentifier" />
			<Output TaskParameter="DetectedBundleId" PropertyName="_BundleIdentifier" />
			<Output TaskParameter="DetectedBundleVersion" PropertyName="_BundleVersion" />
			<Output TaskParameter="DetectedCodeSigningKey" PropertyName="_CodeSigningKey" />
			<Output TaskParameter="DetectedCodesignAllocate" PropertyName="_CodesignAllocate" />
			<Output TaskParameter="DetectedDistributionType" PropertyName="_DistributionType" />
			<Output TaskParameter="DetectedProvisioningProfile" PropertyName="_ProvisioningProfile" />
		</DetectSigningIdentity>
	</Target>
	
	<Target Name="_GenerateBundleName" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_ComputeTargetArchitectures">
		<PropertyGroup>
			<AppBundleDir Condition="'$(IsAppDistribution)' != 'true'">$(DeviceSpecificOutputPath)$(_AppBundleName)$(AppBundleExtension)</AppBundleDir>
			<AppBundleDir Condition="'$(IsAppDistribution)' == 'true'">$(ArchivePath)\Products\Applications\$(_AppBundleName)$(AppBundleExtension)</AppBundleDir>
			<_AppBundlePath>$(AppBundleDir)\</_AppBundlePath>
		</PropertyGroup>
	</Target>

	<Target Name="GetAppBundleDir" DependsOnTargets="_GenerateBundleName" Returns="$(AppBundleDir)"/>

	<Target Name="_CompileAppManifest"
		DependsOnTargets="_DetectSdkLocations;_DetectAppManifest;_GenerateBundleName;_DetectSigningIdentity;_PrepareResourceRules;_ResolveWatchAppReferences;_DetectDebugNetworkConfiguration"
		Inputs="$(_AppManifest);@(_PartialAppManifest)"
		Outputs="$(_AppBundlePath)Info.plist" >
		<CompileAppManifest
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleName="$(_AppBundleName)"
			AppBundleDir="$(AppBundleDir)"
			AppManifest="$(_AppManifest)"
			AssemblyName="$(AssemblyName)"
			BundleIdentifier="$(_BundleIdentifier)"
			Debug="$(MtouchDebug)"
			DefaultSdkVersion="$(MtouchSdkVersion)"
			IsAppExtension="$(IsAppExtension)"
			IsWatchApp="$(IsWatchApp)"
			IsWatchExtension="$(IsWatchExtension)"
			PartialAppManifests="@(_PartialAppManifest)"
			ResourceRules="$(_PreparedResourceRules)"
			TargetArchitectures="$(TargetArchitectures)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			SdkPlatform="$(_SdkPlatform)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			DebugIPAddresses="$(_DebugIPAddresses)"
			UseFakeWatchOS4_3Sdk="$(UseFakeWatchOS4_3Sdk)"
			>
		</CompileAppManifest>

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(AppBundleDir).dSYM" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="$(DeviceSpecificOutputPath)*.bcsymbolmap" />
	</Target>

	<Target Name="_CompileITunesMetadata" Condition="'$(ComputedPlatform)' == 'iPhone' And '$(IsAppExtension)' == 'false' And '$(IsWatchApp)' == 'false'"
		DependsOnTargets="_DetectSdkLocations;_DetectAppManifest;_GenerateBundleName;_CompileAppManifest"
		Inputs="$(_AppManifest);@(ITunesMetadata)"
		Outputs="$(DeviceSPecificOutputPath)iTunesMetadata.plist" >
		<CompileITunesMetadata
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			ITunesMetadata="@(ITunesMetadata)"
			OutputPath="$(DeviceSpecificOutputPath)iTunesMetadata.plist"
		/>
	</Target>

	<Target Name="_CollectITunesArtwork" Condition="'$(ComputedPlatform)' == 'iPhone' And '$(IsAppExtension)' == 'false' And '$(IsWatchApp)' == 'false'">
		<CollectITunesArtwork
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ITunesArtwork="@(ITunesArtwork)"
			>
			<Output TaskParameter="ITunesArtworkWithLogicalNames" ItemName="_ITunesArtworkWithLogicalName"/>
		</CollectITunesArtwork>
	</Target>

	<Target Name="_CopyITunesArtwork" Condition="'$(ComputedPlatform)' == 'iPhone' And '$(IsAppExtension)' == 'false' And '$(IsWatchApp)' == 'false'"
		DependsOnTargets="_CollectITunesArtwork"
		Inputs="@(_ITunesArtworkWithLogicalName)" Outputs="$(DeviceSpecificOutputPath)%(_ITunesArtworkWithLogicalName.LogicalName)">
		<Copy
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			SourceFiles="@(_ITunesArtworkWithLogicalName)"
			DestinationFiles="$(DeviceSpecificOutputPath)%(_ITunesArtworkWithLogicalName.LogicalName)"
		/>
	</Target>

	<Target Name="_GetNativeExecutableName" DependsOnTargets="_DetectAppManifest;_GenerateBundleName;_CompileAppManifest">
		<GetNativeExecutableName
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppManifest="$(_AppBundlePath)Info.plist"
			>
			<Output TaskParameter="ExecutableName" PropertyName="_ExecutableName" />
		</GetNativeExecutableName>

		<PropertyGroup>
			<_NativeExecutable>$(_AppBundlePath)$(_ExecutableName)</_NativeExecutable>
		</PropertyGroup>
	</Target>

	<PropertyGroup>
		<_CompileToNativeDependsOn>
			_DetectAppManifest;
			_DetectSdkLocations;
			_GenerateBundleName;
			_DetectSigningIdentity;
			_CompileEntitlements;
			_CompileAppManifest;
			_ResolveAppExtensionReferences;
			_GetNativeExecutableName;
			_GetCompileToNativeInputs;
			_ExpandNativeReferences;
		</_CompileToNativeDependsOn>
	</PropertyGroup>

	<Target Name="_GetCompileToNativeInputs">
		<ItemGroup>
			<!-- Skip the reference assemblies. There is currently no scenario where it is valid to pass them to 'mtouch'. They are impossible to AOT. Fixes: https://github.com/xamarin/xamarin-macios/issues/3199 -->
			<!-- Remove exact references, such as if a package had a framework reference to 'System' that we already have -->
			<!-- This is exactly what "Microsoft.NuGet.Build.Tasks"'s 'ResolveNuGetPackageAssets' target is doing -->
			<!-- Effectively 'ResolveNuGetPackageAssets' computes the NuGet packages using their json asset file, adds the full assemblies to 'ReferenceCopyLocalPaths' and outputs the resolved references via '_ReferencesFromNuGetPackages' -->
			<!-- This requires nuget libraries to be copied locally, which by default only happens for executable projects, so we set 'CopyNuGetImplementations' to true for extensions (see comment in Xamarin.iOS.AppExtension.CSharp.targets for more info) -->
			<ReferencePath Remove="@(_ReferencesFromNuGetPackages)" />
			<MTouchReferencePath Include="@(ReferenceCopyLocalPaths)" Condition="'%(Extension)' == '.dll'" />
			<_CompileToNativeInput Include="$(TargetDir)$(TargetFileName);@(ReferencePath);@(MTouchReferencePath)" />
			<_CompileToNativeInput Condition="'@(_ResolvedAppExtensionReferences)' != ''" Include="%(_ResolvedAppExtensionReferences.Identity)\..\mtouch.stamp" />
		</ItemGroup>
	</Target>

	<Target Name="_CompileToNative" DependsOnTargets="$(_CompileToNativeDependsOn)"
		Condition = "'$(IsAppDistribution)' != 'true'"
		Inputs="@(_CompileToNativeInput);@(_FrameworkNativeReference);@(_FileNativeReference);@(BundleDependentFiles)"
		Outputs="$(_NativeExecutable);$(DeviceSpecificOutputPath)mtouch.stamp">

		<MTouch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(MtouchExe)"
			ToolPath="$(MtouchPath)"
			AppBundleDir="$(AppBundleDir)"
			AppManifest="$(_AppBundlePath)Info.plist"
			Architectures="$(TargetArchitectures)"
			ExecutableName="$(_ExecutableName)"
			CompiledEntitlements="$(_CompiledEntitlements)"
			Debug="$(MtouchDebug)"
			EnableGenericValueTypeSharing="$(MtouchEnableGenericValueTypeSharing)"
			ExtraArgs="$(MtouchExtraArgs)"
			FastDev="$(MtouchFastDev)"
			HttpClientHandler="$(MtouchHttpClientHandler)"
			I18n="$(MtouchI18n)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)mtouch-cache"
			IsAppExtension="$(IsAppExtension)"
			LinkDescriptions="@(LinkDescription)"
			LinkerDumpDependencies="$(MtouchLinkerDumpDependencies)"
			LinkMode="$(MtouchLink)"
			MainAssembly="$(TargetPath)"
			NativeReferences="@(NativeReference)"
			OutputPath="$(DeviceSpecificOutputPath)"
			Profiling="$(MtouchProfiling)"
			ProjectDir="$(MtouchProjectDirectory)"
			References="@(ReferencePath);@(MTouchReferencePath)"
			ResponseFilePath="$(DeviceSpecificIntermediateOutputPath)response-file.rsp"
			SdkRoot="$(_SdkDevPath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkVersion="$(MtouchSdkVersion)"
			SymbolsList="$(_MtouchSymbolsList)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			TargetFrameworkVersion="$(TargetFrameworkVersion)"
			UseLlvm="$(MtouchUseLlvm)"
			UseFloat32="$(MtouchFloat32)"
			UseThumb="$(MtouchUseThumb)"
			EnableBitcode="$(MtouchEnableBitcode)"
			EnableSGenConc="$(MtouchEnableSGenConc)"
			Interpreter="$(MtouchInterpreter)"
			AppExtensionReferences="@(_ResolvedAppExtensionReferences)"
			ArchiveSymbols="$(MonoSymbolArchive)"
			Verbosity="$(MtouchVerbosity)"
			StandardOutputImportance="High"
			>
			<Output TaskParameter="CompiledArchitectures" PropertyName="_CompiledArchitectures" />
		</MTouch>

		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AlwaysCreate="true"
			Files="$(DeviceSpecificOutputPath)mtouch.stamp"
			>
			<Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
		</Touch>
	</Target>

	<Target Name="_ParseExtraMtouchArgs">
		<ParseExtraMtouchArgs
			ExtraArgs="$(MTouchExtraArgs)"
			NoSymbolStrip="$(MtouchNoSymbolStrip)"
			NoDSymUtil="$(MtouchNoDSymUtil)"
			>
			<Output TaskParameter="NoSymbolStrip" PropertyName="MtouchNoSymbolStrip"/>
			<Output TaskParameter="NoDSymUtil" PropertyName="MtouchNoDSymUtil"/>
		</ParseExtraMtouchArgs>
	</Target>

	<Target Name="_ReadAppExtensionDebugSymbolProperties">
		<ReadItemsFromFile File="%(_ResolvedAppExtensionReferences.Identity)\..\dsym.items" Condition="Exists('%(_ResolvedAppExtensionReferences.Identity)\..\dsym.items')">
			<Output TaskParameter="Items" ItemName="_AppExtensionDebugSymbolProperties" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_GenerateAppExtensionDebugSymbols" Condition="'$(ComputedPlatform)' == 'iPhone' And '$(IsAppExtension)' == 'false'"
		DependsOnTargets="_ParseExtraMtouchArgs;_CompileToNative;_ReadAppExtensionDebugSymbolProperties"
		Inputs="$(_AppBundlePath)PlugIns\%(_AppExtensionDebugSymbolProperties.Identity)\%(_AppExtensionDebugSymbolProperties.NativeExecutable)"
		Outputs="$(AppBundleDir)\..\%(_AppExtensionDebugSymbolProperties.Identity).dSYM\Contents\Info.plist">

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(AppBundleDir)\..\%(_AppExtensionDebugSymbolProperties.Identity).dSYM" />

		<!-- run dsymutil on the main bundle -->
		<DSymUtil
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '%(_AppExtensionDebugSymbolProperties.NoDSymUtil)' == 'false'"
			AppBundleDir="$(_AppBundlePath)PlugIns\%(_AppExtensionDebugSymbolProperties.Identity)"
			Architectures="%(_AppExtensionDebugSymbolProperties.CompiledArchitectures)"
			DSymDir="$(AppBundleDir)\..\%(_AppExtensionDebugSymbolProperties.Identity).dSYM"
			Executable="$(_AppBundlePath)PlugIns\%(_AppExtensionDebugSymbolProperties.Identity)\%(_AppExtensionDebugSymbolProperties.NativeExecutable)"
			ToolExe="$(DSymUtilExe)"
			ToolPath="$(DSymUtilPath)"
		>
		</DSymUtil>

		<!-- strip the debug symbols from the $(_NativeExecutable) -->
		<SymbolStrip
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '%(_AppExtensionDebugSymbolProperties.NoSymbolStrip)' == 'false'"
			Executable="$(_AppBundlePath)PlugIns\%(_AppExtensionDebugSymbolProperties.Identity)\%(_AppExtensionDebugSymbolProperties.NativeExecutable)"
			IsFramework="false"
			SymbolFile="%(_AppExtensionDebugSymbolProperties.SymbolsList)"
		>
		</SymbolStrip>

		<!-- touch the dSYM Info.plist so that its mtime is newer than the stripped $(_NativeExecutable) -->
		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '%(_AppExtensionDebugSymbolProperties.NoSymbolStrip)' == 'false'"
			Files="$(AppBundleDir)\..\%(_AppExtensionDebugSymbolProperties.Identity).dSYM\Contents\Info.plist"
		>
		</Touch>
	</Target>

	<Target Name="_GenerateFrameworkDebugSymbols" Condition="'$(ComputedPlatform)' == 'iPhone' And '$(IsWatchApp)' == 'false'" DependsOnTargets="_CompileToNative;_ParseExtraMtouchArgs;_CollectFrameworks"
		Inputs="%(_Frameworks.Identity)"
		Outputs="$(AppBundleDir)\..\%(_Frameworks.Filename).framework.dSYM\Contents\Info.plist"
		>

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(AppBundleDir)\..\%(_Frameworks.Filename).framework.dSYM" />

		<!-- run dsymutil on embedded frameworks -->
		<DSymUtil
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(MtouchNoDSymUtil)' == 'false'"
			AppBundleDir="$(AppBundleDir)"
			Architectures=""
			DSymDir="$(AppBundleDir)\..\%(_Frameworks.Filename).framework.dSYM"
			Executable="%(_Frameworks.Identity)"
			ToolExe="$(DSymUtilExe)"
			ToolPath="$(DSymUtilPath)">
		</DSymUtil>

		<!-- strip embedded frameworks -->
		<SymbolStrip
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(MtouchNoSymbolStrip)' == 'false'"
			Executable="%(_Frameworks.Identity)"
			IsFramework="true"
			SymbolFile=""
		>
		</SymbolStrip>

		<!-- _GenerateDebugSymbols will run spotlight to index the dSYMs -->
	</Target>

	<Target Name="_PrepareDebugSymbolGeneration" Condition="'$(ComputedPlatform)' == 'iPhone' And '$(IsAppExtension)' == 'true' And '$(IsWatchApp)' == 'false'" DependsOnTargets="_CompileToNative;_ParseExtraMtouchArgs"
			Inputs="$(_NativeExecutable)" Outputs="$(DeviceSpecificOutputPath)dsym.items">
		<!-- For App Extensions, we delay running dsymutil & strip until it has been copied into the main app bundle... -->
		<GetFullPath SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" RelativePath="$(_MtouchSymbolsList)">
			<Output TaskParameter="FullPath" PropertyName="_SymbolsListFullPath" />
		</GetFullPath>

		<PropertyGroup>
			<!-- [System.IO.Path]::GetFileName() is safe to use -->
			<_NativeExecutableFileName>$([System.IO.Path]::GetFileName('$(_NativeExecutable)'))</_NativeExecutableFileName>
			<_AppBundleFileName>$([System.IO.Path]::GetFileName('$(AppBundleDir)'))</_AppBundleFileName>
		</PropertyGroup>

		<ItemGroup>
			<_AppExtensionDebugSymbolProperties Remove="@(_AppExtensionDebugSymbolProperties)" />

			<_AppExtensionDebugSymbolProperties Include="$(_AppBundleFileName)">
				<CompiledArchitectures>$(_CompiledArchitectures)</CompiledArchitectures>
				<NativeExecutable>$(_NativeExecutableFileName)</NativeExecutable>
				<NoSymbolStrip>$(MtouchNoSymbolStrip)</NoSymbolStrip>
				<SymbolsList>$(_SymbolsListFullPath)</SymbolsList>
				<NoDSymUtil>$(MtouchNoDSymUtil)</NoDSymUtil>
			</_AppExtensionDebugSymbolProperties>
		</ItemGroup>

		<WriteItemsToFile
			Condition="'$(IsMacEnabled)' == 'true'"
			Items="@(_AppExtensionDebugSymbolProperties)"
			ItemName="_AppExtensionDebugSymbolProperties"
			File="$(DeviceSpecificOutputPath)dsym.items"
			IncludeMetadata="true"
			Overwrite="true"
		/>
	</Target>

	<Target Name="_GenerateDebugSymbols" Condition="'$(ComputedPlatform)' == 'iPhone' And '$(IsWatchApp)' == 'false'" DependsOnTargets="_CompileToNative;_ParseExtraMtouchArgs;_GenerateFrameworkDebugSymbols;_GenerateAppExtensionDebugSymbols;_PrepareDebugSymbolGeneration"
		Inputs="$(_NativeExecutable)" Outputs="$(AppBundleDir).dSYM\Contents\Info.plist">

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'false'" Directories="$(AppBundleDir).dSYM" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'false'" Files="$(DeviceSpecificOutputPath)*.bcsymbolmap" />

		<!-- run dsymutil on the main bundle -->
		<DSymUtil
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(MtouchNoDSymUtil)' == 'false' And '$(IsAppExtension)' == 'false'"
			AppBundleDir="$(AppBundleDir)"
			Architectures="$(_CompiledArchitectures)"
			DSymDir="$(AppBundleDir).dSYM"
			Executable="$(_NativeExecutable)"
			ToolExe="$(DSymUtilExe)"
			ToolPath="$(DSymUtilPath)"
		>
		</DSymUtil>

		<!-- strip the debug symbols from the $(_NativeExecutable) -->
		<SymbolStrip
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(MtouchNoSymbolStrip)' == 'false' And '$(IsAppExtension)' == 'false'"
			Executable="$(_NativeExecutable)"
			IsFramework="false"
			SymbolFile="$(_MtouchSymbolsList)"
		>
		</SymbolStrip>

		<!-- touch the dSYM Info.plist so that its mtime is newer than the stripped $(_NativeExecutable) -->
		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(MtouchNoSymbolStrip)' == 'false' And '$(IsAppExtension)' == 'false' And Exists('$(AppBundleDir).dSYM')"
			Files="$(AppBundleDir).dSYM\Contents\Info.plist"
		>
		</Touch>

		<!-- make sure spotlight indexes everything we've built -->
		<SpotlightIndexer
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(MtouchNoDSymUtil)' == 'false' And '$(IsAppExtension)' == 'false'"
			Input="$(AppBundleDir)/../"
		>
		</SpotlightIndexer>
	</Target>

	<Target Name="_CreateDebugSettings" Condition="'$(MtouchDebug)' == 'true' And '$(IsWatchApp)' == 'false'"
		DependsOnTargets="_CopyResourcesToBundle"
		Outputs="$(_AppBundlePath)Settings.bundle\Root.plist" >
		<CreateDebugSettings
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			DebuggerPort="$(IOSDebuggerPort)"
			>
		</CreateDebugSettings>
	</Target>

	<Target Name="_CreateDebugConfiguration" Condition="'$(MtouchDebug)' == 'true' And '$(IsWatchApp)' == 'false'"
		DependsOnTargets="_CopyResourcesToBundle;_DetectDebugNetworkConfiguration"
		Outputs="$(_AppBundlePath)MonoTouchDebugConfiguration.txt" >
		<CreateDebugConfiguration
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			DebugOverWiFi="$(IOSDebugOverWiFi)"
			DebugIPAddresses="$(_DebugIPAddresses)"
			DebuggerPort="$(IOSDebuggerPort)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			>
		</CreateDebugConfiguration>
	</Target>

	<Target Name="_CollectPngImages" DependsOnTargets="_CollectBundleResources">
		<CreateItem Include="@(_BundleResourceWithLogicalName)" Condition="'%(_BundleResourceWithLogicalName.Extension)' == '.png' And '%(_BundleResourceWithLogicalName.Optimize)' == 'true'">
			<Output TaskParameter="Include" ItemName="_PngImage" />
		</CreateItem>
	</Target>

	<Target Name="_CoreOptimizePngImages"
		DependsOnTargets="_CollectPngImages;_DetectSdkLocations"
		Inputs="@(_PngImage)"
		Outputs="@(_PngImage -> '$(DeviceSpecificIntermediateOutputPath)optimized\%(LogicalName)')">

		<OptimizeImage
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(PngCrushExe)"
			ToolPath="$(PngCrushPath)"
			SdkDevPath="$(_SdkDevPath)"
			InputImages="@(_PngImage)"
			OutputImages="@(_PngImage -> '$(DeviceSpecificIntermediateOutputPath)optimized\%(LogicalName)')">
			<Output TaskParameter="OutputImages" ItemName="FileWrites" />
		</OptimizeImage>
	</Target>

	<Target Name="_AfterCoreOptimizePngImages" Condition="'@(_PngImage)' != ''">
		<ItemGroup>
			<_BundleResourceWithLogicalName Remove="@(_PngImage)" />
		</ItemGroup>

		<CreateItem Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PngImage.LogicalName)" AdditionalMetadata="LogicalName=%(_PngImage.LogicalName);Optimize='false';ResourceTags=%(_PngImage.ResourceTags)">
			<Output TaskParameter="Include" ItemName="_BundleResourceWithLogicalName" />
		</CreateItem>
	</Target>

	<Target Name="_CollectPropertyLists" DependsOnTargets="_CollectBundleResources">
		<CreateItem Include="@(_BundleResourceWithLogicalName)" Condition="'%(_BundleResourceWithLogicalName.Extension)' == '.plist' And '%(_BundleResourceWithLogicalName.Optimize)' == 'true'">
			<Output TaskParameter="Include" ItemName="_PropertyList" />
		</CreateItem>
		<ItemGroup>
			<FileWrites Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PropertyList.LogicalName)" />
		</ItemGroup>
	</Target>

	<Target Name="_CoreOptimizePropertyLists"
		DependsOnTargets="_CollectPropertyLists;_DetectSdkLocations"
		Inputs="@(_PropertyList)"
		Outputs="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PropertyList.LogicalName)"
		>

		<OptimizePropertyList
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(PlUtilExe)"
			ToolPath="$(PlUtilPath)"
			Input="%(_PropertyList.Identity)"
			Output="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PropertyList.LogicalName)">
		</OptimizePropertyList>
	</Target>

	<Target Name="_AfterCoreOptimizePropertyLists" Condition="'@(_PropertyList)' != ''">
		<ItemGroup>
			<_BundleResourceWithLogicalName Remove="@(_PropertyList)" />
		</ItemGroup>

		<CreateItem Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PropertyList.LogicalName)" AdditionalMetadata="LogicalName=%(_PropertyList.LogicalName);Optimize='false'">
			<Output TaskParameter="Include" ItemName="_BundleResourceWithLogicalName" />
		</CreateItem>
	</Target>

	<Target Name="_CollectLocalizationFiles" DependsOnTargets="_CollectBundleResources">    
		<CreateItem Include="@(_BundleResourceWithLogicalName)" Condition="'%(_BundleResourceWithLogicalName.Extension)' == '.strings' And '%(_BundleResourceWithLogicalName.Optimize)' == 'true'">
			<Output TaskParameter="Include" ItemName="_LocalizationFile" />
		</CreateItem>
		<ItemGroup>
			<FileWrites Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_LocalizationFile.LogicalName)" />
		</ItemGroup>
	</Target>

	<Target Name="_CoreOptimizeLocalizationFiles"
		DependsOnTargets="_CollectLocalizationFiles;_DetectSdkLocations"
		Inputs="@(_LocalizationFile)"
		Outputs="$(DeviceSpecificIntermediateOutputPath)optimized\%(_LocalizationFile.LogicalName)"
		>

		<OptimizePropertyList
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(PlUtilExe)"
			ToolPath="$(PlUtilPath)"
			Input="%(_LocalizationFile.Identity)"
			Output="$(DeviceSpecificIntermediateOutputPath)optimized\%(_LocalizationFile.LogicalName)">
		</OptimizePropertyList>
	</Target>

	<Target Name="_AfterCoreOptimizeLocalizationFiles" Condition="'@(_LocalizationFile)' != ''">
		<ItemGroup>
			<_BundleResourceWithLogicalName Remove="@(_LocalizationFile)" />
		</ItemGroup>

		<CreateItem Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_LocalizationFile.LogicalName)" AdditionalMetadata="LogicalName=%(_LocalizationFile.LogicalName);Optimize='false'">
			<Output TaskParameter="Include" ItemName="_BundleResourceWithLogicalName" />
		</CreateItem>
	</Target>

	<Target Name="_CollectColladaAssets">
		<CollectBundleResources
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			BundleResources="@(Collada)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)">
			<Output TaskParameter="BundleResourcesWithLogicalNames" ItemName="_ColladaAssetWithLogicalName" />
		</CollectBundleResources>
	</Target>

	<Target Name="_CoreCompileColladaAssets"
		DependsOnTargets="_CollectColladaAssets;_DetectSdkLocations"
		Inputs="@(_ColladaAssetWithLogicalName)"
		Outputs="$(DeviceSpecificIntermediateOutputPath)%(_ColladaAssetWithLogicalName.LogicalName)"
		>

		<ScnTool
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(ScnToolExe)"
			ToolPath="$(ScnToolPath)"
			SdkRoot="$(_SdkRoot)"
			SdkDevPath="$(_SdkDevPath)"
			SdkVersion="$(MtouchSdkVersion)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			InputScene="%(_ColladaAssetWithLogicalName.Identity)"
			OutputScene="$(DeviceSpecificIntermediateOutputPath)%(_ColladaAssetWithLogicalName.LogicalName)">
		</ScnTool>

		<CreateItem Include="$(DeviceSpecificIntermediateOutputPath)%(_ColladaAssetWithLogicalName.LogicalName)" AdditionalMetadata="LogicalName=%(_ColladaAssetWithLogicalName.LogicalName);Optimize='False'">
			<Output TaskParameter="Include" ItemName="_BundleResourceWithLogicalName" />
		</CreateItem>
	</Target>

	<Target Name="_CompileImageAssets" DependsOnTargets="_DetectAppManifest;_DetectSdkLocations;_ComputeTargetArchitectures;_BeforeCoreCompileImageAssets;_ReadCompileImageAssets;_CoreCompileImageAssets" />

	<Target Name="_BeforeCoreCompileImageAssets"
		Inputs="@(ImageAsset);$(_AppManifest)"
		Outputs="$(_ACTool_PartialAppManifestCache);$(_ACTool_BundleResourceCache)">
		
		<!-- If any ImageAsset or AppManifest is newer than the generated items list, we delete them so that the _CoreCompileImageAssets
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_ACTool_PartialAppManifestCache);$(_ACTool_BundleResourceCache)" />
		<RemoveDir Directories="$(DeviceSpecificIntermediateOutputPath)actool" />
	</Target>

	<Target Name="_ReadCompileImageAssets"					
		DependsOnTargets="_BeforeCoreCompileImageAssets">

		<!-- If _BeforeCoreCompileImageAssets did not delete the generated items lists from _CoreCompileImageAsset, then we read them
		     since that target won't run and we need the output items that are cached in those files, which includes full metadata -->
		<ReadItemsFromFile File="$(_ACTool_PartialAppManifestCache)" Condition="Exists('$(_ACTool_PartialAppManifestCache)')">
			<Output TaskParameter="Items" ItemName="_PartialAppManifest" />
		</ReadItemsFromFile>
		<ReadItemsFromFile File="$(_ACTool_BundleResourceCache)" Condition="Exists('$(_ACTool_BundleResourceCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_CoreCompileImageAssets" 
		Inputs="@(ImageAsset);$(_AppManifest)"
		Outputs="$(_ACTool_PartialAppManifestCache);$(_ACTool_BundleResourceCache)"
		DependsOnTargets="_DetectAppManifest;_DetectSdkLocations;_BeforeCoreCompileImageAssets">

		<ACTool
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(ImageAsset)' != ''"
			ToolExe="$(ACToolExe)"
			ToolPath="$(ACToolPath)"
			AppManifest="$(_AppManifest)"
			DeviceModel="$(TargetDeviceModel)"
			DeviceOSVersion="$(TargetDeviceOSVersion)"
			EnableOnDemandResources="$(EnableOnDemandResources)"
			ImageAssets="@(ImageAsset)"
			OptimizePNGs="$(OptimizePNGs)"
			OutputPath="$(DeviceSpecificOutputPath)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			IsWatchApp="$(IsWatchApp)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)"
			SdkBinPath="$(_SdkBinPath)"
			SdkUsrPath="$(_SdkUsrPath)"
			SdkPlatform="$(_SdkPlatform)"
			SdkVersion="$(MtouchSdkVersion)">
			<Output TaskParameter="PartialAppManifest" ItemName="_PartialAppManifest" />
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="PartialAppManifest" ItemName="_ACTool_PartialAppManifest" />
			<Output TaskParameter="BundleResources" ItemName="_ACTool_BundleResources" />
		</ACTool>

		<!-- Cache the generated outputs items for incremental build support -->
		<WriteItemsToFile Items="@(_ACTool_PartialAppManifest)" ItemName="_PartialAppManifest" File="$(_ACTool_PartialAppManifestCache)" Overwrite="true" IncludeMetadata="true" />
		<WriteItemsToFile Items="@(_ACTool_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_ACTool_BundleResourceCache)" Overwrite="true" IncludeMetadata="true" />
		<ItemGroup>
			<FileWrites Include="$(_ACTool_PartialAppManifestCache);$(_ACTool_BundleResourceCache)" />
		</ItemGroup>
	</Target>

	<Target Name="_CompileSceneKitAssets" DependsOnTargets="_DetectAppManifest;_DetectSdkLocations;_ComputeTargetArchitectures;_BeforeCoreCompileSceneKitAssets;_ReadCoreCompileSceneKitAssets;_CoreCompileSceneKitAssets" />

	<Target Name="_BeforeCoreCompileSceneKitAssets"
		Inputs="@(SceneKitAsset)"
		Outputs="$(_SceneKitCache)">

		<!-- If any SceneKitAsset is newer than the generated items list, we delete them so that the _CoreCompileSceneKitAssets 
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_SceneKitCache)" />
	</Target>

	<Target Name="_ReadCoreCompileSceneKitAssets"
		DependsOnTargets="_BeforeCoreCompileSceneKitAssets">

		<!-- If _BeforeCoreCompileSceneKitAssets did not delete the generated items lists from _CoreCompileSceneKitAssets, then we read them
		     since that target won't run and we need to the output items that are cached in those files which includes full metadata -->
		<ReadItemsFromFile File="$(_SceneKitCache)" Condition="Exists('$(_SceneKitCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_CoreCompileSceneKitAssets"
		Inputs="@(SceneKitAsset)"
		Outputs="$(_SceneKitCache)"
		DependsOnTargets="_BeforeCoreCompileSceneKitAssets;_GenerateBundleName">

		<CompileSceneKitAssets
			SessionId="$(BuildSessionId)"
			AppBundleName="$(_AppBundleName)$(AppBundleExtension)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(CopySceneKitAssetsExe)"
			ToolPath="$(CopySceneKitAssetsPath)"
			SceneKitAssets="@(SceneKitAsset)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			IsWatchApp="$(IsWatchApp)"
			SdkPlatform="$(_SdkPlatform)"
			SdkDevPath="$(_SdkDevPath)"
			SdkRoot="$(_SdkRoot)"
			SdkVersion="$(MtouchSdkVersion)">
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="BundleResources" ItemName="_SceneKitAssets_BundleResources" />
		</CompileSceneKitAssets>

		<WriteItemsToFile Items="@(_SceneKitAssets_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_SceneKitCache)" Overwrite="true" IncludeMetadata="true" />
		<ItemGroup>
			<FileWrites Include="$(_SceneKitCache)" />
		</ItemGroup>
	</Target>
	
	<Target Name="_CompileInterfaceDefinitions" DependsOnTargets="_DetectAppManifest;_DetectSdkLocations;_ComputeTargetArchitectures;_BeforeCoreCompileInterfaceDefinitions;_ReadCoreCompileInterfaceDefinitions;_CoreCompileInterfaceDefinitions" />
	
	<Target Name="_BeforeCoreCompileInterfaceDefinitions"
		Inputs="@(InterfaceDefinition)"
		Outputs="$(_IBToolCache)">

		<!-- If any InterfaceDefinition is newer than the generated items list, we delete them so that the _CoreCompileInterfaceDefinitions 
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_IBToolCache)" />
	</Target>

	<Target Name="_ReadCoreCompileInterfaceDefinitions"	DependsOnTargets="_BeforeCoreCompileInterfaceDefinitions">
		<!-- If _BeforeCoreCompileInterfaceDefinitions did not delete the generated items lists from _CoreCompileInterfaceDefinitions, then we read them
		     since that target won't run and we need to the output items that are cached in those files which includes full metadata -->
		<ReadItemsFromFile File="$(_IBToolCache)" Condition="Exists('$(_IBToolCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_CoreCompileInterfaceDefinitions"
		Inputs="@(InterfaceDefinition)"
		Outputs="$(_IBToolCache)"
		DependsOnTargets="_BeforeCoreCompileInterfaceDefinitions">

		<IBTool
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(IBToolExe)"
			ToolPath="$(IBToolPath)"
			AppManifest="$(_AppManifest)"
			EnableOnDemandResources="$(EnableOnDemandResources)"
			InterfaceDefinitions="@(InterfaceDefinition)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			IsWatchApp="$(IsWatchApp)"
			IsWatch2App="$(IsWatch2App)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)"
			SdkBinPath="$(_SdkBinPath)"
			SdkUsrPath="$(_SdkUsrPath)"
			SdkRoot="$(_SdkRoot)"
			SdkPlatform="$(_SdkPlatform)"
			SdkVersion="$(MtouchSdkVersion)">
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="BundleResources" ItemName="_IBTool_BundleResources" />
		</IBTool>

		<!-- Cached the generated outputs items for incremental build support -->
		<WriteItemsToFile Items="@(_IBTool_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_IBToolCache)" Overwrite="true" IncludeMetadata="true" />
		<ItemGroup>
			<FileWrites Include="$(_IBToolCache)" />
		</ItemGroup>
	</Target>

	<Target Name="_CompileTextureAtlases" DependsOnTargets="_DetectAppManifest;_DetectSdkLocations;_BeforeCompileTextureAtlases;_ReadCoreCompileTextureAtlases;_CoreCompileTextureAtlases" />

	<Target Name="_BeforeCompileTextureAtlases"
		Inputs="@(AtlasTexture)"
		Outputs="$(_TextureAtlasCache)">

		<!-- If any AtlasTexture is newer than the generated items list, we delete them so that the _CoreCompileTextureAtlases 
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_TextureAtlasCache)" />
	</Target>

	<Target Name="_ReadCoreCompileTextureAtlases"
					DependsOnTargets="_BeforeCompileTextureAtlases">

		<!-- If _BeforeCompileTextureAtlases did not delete the generated items lists from _CoreCompileTextureAtlases, then we read them
		     since that target won't run and we need to the output items that are cached in those files which includes full metadata -->
		<ReadItemsFromFile File="$(_TextureAtlasCache)" Condition="Exists('$(_TextureAtlasCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_CoreCompileTextureAtlases"
		Inputs="@(AtlasTexture)"
		Outputs="$(_TextureAtlasCache)"
		DependsOnTargets="_BeforeCompileTextureAtlases">

		<TextureAtlas
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(TextureAtlasExe)"
			ToolPath="$(TextureAtlasPath)"
			AtlasTextures="@(AtlasTexture)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)"
			SdkBinPath="$(_SdkBinPath)"
			SdkUsrPath="$(_SdkUsrPath)">
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="BundleResources" ItemName="_TextureAtlas_BundleResources" />
		</TextureAtlas>

		<!-- Cached the generated outputs items for incremental build support -->
		<WriteItemsToFile Items="@(_TextureAtlas_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_TextureAtlasCache)" Overwrite="true" IncludeMetadata="true" />
		<ItemGroup>
			<FileWrites Include="$(_TextureAtlasCache)" />
		</ItemGroup>
	</Target>

	<Target Name="_CompileCoreMLModels" DependsOnTargets="_DetectAppManifest;_DetectSdkLocations;_ComputeTargetArchitectures;_BeforeCompileCoreMLModels;_ReadCompileCoreMLModels;_CoreCompileCoreMLModels" />

	<Target Name="_BeforeCompileCoreMLModels"
		Inputs="@(CoreMLModel);$(_AppManifest)"
		Outputs="$(_CoreMLModel_PartialAppManifestCache);$(_CoreMLModel_BundleResourceCache)">
		<!-- If any CoreMLModel or AppManifest is newer than the generated items list, we delete them so that the _CoreCompileCoreMLModels
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_CoreMLModel_PartialAppManifestCache);$(_CoreMLModel_BundleResourceCache)" />
		<RemoveDir Directories="$(DeviceSpecificIntermediateOutputPath)coremlc" />
	</Target>

	<Target Name="_ReadCompileCoreMLModels"	DependsOnTargets="_BeforeCompileCoreMLModels">
		<!-- If _BeforeCompileCoreMLModels did not delete the generated items lists from _CoreCompileCoreMLModels, then we read them
		     since that target won't run and we need the output items that are cached in those files, which includes full metadata -->
		<ReadItemsFromFile File="$(_CoreMLModel_PartialAppManifestCache)" Condition="Exists('$(_CoreMLModel_PartialAppManifestCache)')">
			<Output TaskParameter="Items" ItemName="_PartialAppManifest" />
		</ReadItemsFromFile>
		<ReadItemsFromFile File="$(_CoreMLModel_BundleResourceCache)" Condition="Exists('$(_CoreMLModel_BundleResourceCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_CoreCompileCoreMLModels" 
		Inputs="@(CoreMLModel);$(_AppManifest)"
		Outputs="$(_CoreMLModel_PartialAppManifestCache);$(_CoreMLModel_BundleResourceCache)"
		DependsOnTargets="_DetectAppManifest;_DetectSdkLocations;_BeforeCompileCoreMLModels">

		<CoreMLCompiler
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(CoreMLCompilerExe)"
			ToolPath="$(CoreMLCompilerPath)"
			Models="@(CoreMLModel)"
			EnableOnDemandResources="$(EnableOnDemandResources)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(IPhoneResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)">
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />
			<Output TaskParameter="PartialAppManifests" ItemName="_PartialAppManifest" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="PartialAppManifests" ItemName="_CoreMLModel_PartialAppManifest" />
			<Output TaskParameter="BundleResources" ItemName="_CoreMLModel_BundleResources" />
		</CoreMLCompiler>

		<!-- Cache the generated outputs items for incremental build support -->
		<WriteItemsToFile Items="@(_CoreMLModel_PartialAppManifest)" ItemName="_PartialAppManifest" File="$(_CoreMLModel_PartialAppManifestCache)" Overwrite="true" IncludeMetadata="true" />
		<WriteItemsToFile Items="@(_CoreMLModel_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_CoreMLModel_BundleResourceCache)" Overwrite="true" IncludeMetadata="true" />
		<ItemGroup>
			<FileWrites Include="$(_CoreMLModel_PartialAppManifestCache);$(_CoreMLModel_BundleResourceCache)" />
		</ItemGroup>
	</Target>

	<Target Name="_CreatePkgInfo" Condition="'$(IsAppExtension)' == 'false'" DependsOnTargets="_GenerateBundleName" Outputs="$(_AppBundlePath)PkgInfo">
		<CreatePkgInfo SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" OutputPath="$(_AppBundlePath)PkgInfo" />
	</Target>

	<Target Name="_EmbedMobileProvision" Condition="'$(_RequireCodeSigning)' == 'true'" DependsOnTargets="_GenerateBundleName;_DetectSigningIdentity"
		Outputs="$(_AppBundlePath)embedded.mobileprovision">
		<EmbedMobileProvision
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			ProvisioningProfile="$(_ProvisioningProfile)"
			SdkPlatform="$(_SdkPlatform)"
			>
		</EmbedMobileProvision>
	</Target>

	<Target Name="_CompileEntitlements" Condition="'$(_RequireCodeSigning)' == 'true' Or '$(CodesignEntitlements)' != ''" DependsOnTargets="_DetectSdkLocations;_GenerateBundleName;_DetectSigningIdentity"
		Outputs="$(DeviceSpecificIntermediateOutputPath)Entitlements.xcent">
		<CompileEntitlements
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			AppIdentifier="$(_AppIdentifier)"
			BundleIdentifier="$(_BundleIdentifier)"
			Entitlements="$(CodesignEntitlements)"
			CompiledEntitlements="$(DeviceSpecificIntermediateOutputPath)Entitlements.xcent"
			IsAppExtension="$(IsAppExtension)"
			ProvisioningProfile="$(_ProvisioningProfile)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkPlatform="$(_SdkPlatform)"
			SdkVersion="$(MtouchSdkVersion)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
			>

			<!-- We output the same task parameter to 2 different properties because they will be used differently -->

			<!-- $(_CompiledEntitlements) will be passed to the MTouch task (only really needed for iOS Simulator builds,
				 but does not cause harm when set for device builds). -->
			<Output TaskParameter="CompiledEntitlements" PropertyName="_CompiledEntitlements" />

			<!-- $(_CompiledCodesignEntitlements) will be used only with Codesign tasks when building for device. MUST NOT BE SET for iOS Simulator builds. -->
			<Output TaskParameter="CompiledEntitlements" PropertyName="_CompiledCodesignEntitlements" Condition="'$(_SdkIsSimulator)' == 'false'" />
		</CompileEntitlements>
	</Target>

	<Target Name="_PrepareResourceRules" DependsOnTargets="_DetectSdkLocations;_GenerateBundleName">
		<PrepareResourceRules
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(CodesignResourceRules)' != '' And '$(ComputedPlatform)' == 'iPhone'"
			AppBundleDir="$(AppBundleDir)"
			ResourceRules="$(CodesignResourceRules)"
			SdkVersion="$(MtouchSdkVersion)"
			>
			<Output TaskParameter="PreparedResourceRules" PropertyName="_PreparedResourceRules"/>
		</PrepareResourceRules>
	</Target>

	<Target Name="_SeparateAppExtensionReferences" BeforeTargets="AssignProjectConfiguration">
		<CreateItem Include="@(ProjectReference)" PreserveExistingMetadata="true" Condition="'%(Identity)' != '' And '%(ProjectReference.IsAppExtension)' == 'true'">
			<Output ItemName="_AppExtensionReference" TaskParameter="Include" />
		</CreateItem>

		<ItemGroup>
			<ProjectReference Remove="@(_AppExtensionReference)" />
		</ItemGroup>

		<!--<Warning Text="_SeparateAppExtensionReferences: @(_AppExtensionReference)"/>-->
	</Target>

	<Target Name="_AssignAppExtensionConfiguration" Condition="'@(_AppExtensionReference)' != ''">
		<!-- assign configs if building a solution file -->
		<AssignProjectConfiguration
			ProjectReferences = "@(_AppExtensionReference)"
			SolutionConfigurationContents = "$(CurrentSolutionConfigurationContents)"
			Condition="'$(CurrentSolutionConfigurationContents)' != ''">

			<Output TaskParameter="AssignedProjects" ItemName="_AppExtensionReferenceWithConfiguration"/>
		</AssignProjectConfiguration>

		<!-- Else, just -->
		<CreateItem Include="@(_AppExtensionReference)"
					Condition="'$(CurrentSolutionConfigurationContents)' == ''">
			<Output TaskParameter="Include" ItemName="_AppExtensionReferenceWithConfiguration"/>
		</CreateItem>

		<!--<Warning Text="_AssignAppExtensionConfiguration: @(_AppExtensionReferenceWithConfiguration)"/>-->
	</Target>

	<!-- Split iOS App Extension projects into 2 lists
		_AppExtensionReferenceWithConfigurationExistent: Projects existent on disk
		_AppExtensionReferenceWithConfigurationNonExistent: Projects non-existent on disk -->
	<Target Name="_SplitAppExtensionReferencesByExistent" DependsOnTargets="_AssignAppExtensionConfiguration">
		<CreateItem Include="@(_AppExtensionReferenceWithConfiguration)" Condition="'@(_AppExtensionReferenceWithConfiguration)' != ''">
			<Output TaskParameter="Include" ItemName="_AppExtensionReferenceWithConfigurationExistent" 
				Condition="Exists ('%(_AppExtensionReferenceWithConfiguration.Identity)')"/>

			<Output TaskParameter="Include" ItemName="_AppExtensionReferenceWithConfigurationNonExistent"
				Condition="!Exists ('%(_AppExtensionReferenceWithConfiguration.Identity)')"/>
		</CreateItem>

		<!--<Warning Text="_SplitAppExtensionReferencesByExistent: @(_AppExtensionReferenceWithConfigurationExistent)"/>-->
	</Target>

	<Target Name="_ResolveAppExtensionReferences" DependsOnTargets="_SplitAppExtensionReferencesByExistent">
		<PropertyGroup>
			<!-- When building a .sln with msbuild, the dependent projects may not be built. So, always build
			     the referenced projects unless building from IDE. -->
			<_BuildReferencedExtensionProjects Condition="'$(BuildingInsideVisualStudio)' != 'true'">true</_BuildReferencedExtensionProjects>
		</PropertyGroup>

		<!-- If the referenced projects have already been built, then just get the target paths -->
		<MSBuild
			Projects="@(_AppExtensionReferenceWithConfigurationExistent)"
			Targets="GetBundleTargetPath"
			Properties="%(_AppExtensionReferenceWithConfigurationExistent.SetConfiguration); %(_AppExtensionReferenceWithConfigurationExistent.SetPlatform)"
			Condition="'@(_AppExtensionReferenceWithConfigurationExistent)' != '' and '$(_BuildReferencedExtensionProjects)' != 'true'">

			<Output TaskParameter="TargetOutputs" ItemName="_ResolvedAppExtensionReferences" Condition="'%(_AppExtensionReferenceWithConfigurationExistent.ReferenceOutputAssembly)' != 'false'"/>
		</MSBuild>

		<!-- Build the referenced project if required -->
		<MSBuild
			Projects="@(_AppExtensionReferenceWithConfigurationExistent)"
			Properties="%(_AppExtensionReferenceWithConfigurationExistent.SetConfiguration); %(_AppExtensionReferenceWithConfigurationExistent.SetPlatform)"
			Condition="'@(_AppExtensionReferenceWithConfigurationExistent)' != '' and '$(_BuildReferencedExtensionProjects)' == 'true' ">

			<Output TaskParameter="TargetOutputs" ItemName="_ResolvedAppExtensionReferences" Condition="'%(_AppExtensionReferenceWithConfigurationExistent.ReferenceOutputAssembly)' != 'false'"/>
		</MSBuild>

		<Warning Text="Referenced iOS App Extension Project %(_AppExtensionReferenceWithConfigurationNonExistent.Identity) not found, ignoring."
			 Condition="'@(_AppExtensionReferenceWithConfigurationNonExistent)' != ''"/>
	</Target>

	<Target Name="_DetectDebugNetworkConfiguration">
		<DetectDebugNetworkConfiguration
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			DebugOverWiFi="$(IOSDebugOverWiFi)"
			DebuggerHosts="$(IOSDebuggerHosts)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			>

			<Output TaskParameter="DebugIPAddresses" PropertyName="_DebugIPAddresses" />
		</DetectDebugNetworkConfiguration>
	</Target>

	<Target Name="_CopyAppExtensionsToBundle" DependsOnTargets="_ResolveAppExtensionReferences" Inputs="@(_ResolvedAppExtensionReferences)" 
		  Outputs="$(_AppBundlePath)PlugIns\%(_ResolvedAppExtensionReferences.FileName)%(_ResolvedAppExtensionReferences.Extension)">
		
		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '@(_ResolvedAppExtensionReferences)' != ''" Directories="$(_AppBundlePath)PlugIns" />

		<Ditto
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ResolvedAppExtensionReferences)' != '' And '%(_ResolvedAppExtensionReferences.Identity)' != ''"
			ToolExe="$(DittoExe)"
			ToolPath="$(DittoPath)"
			Source="@(_ResolvedAppExtensionReferences)"
			Destination="$(_AppBundlePath)PlugIns\%(_ResolvedAppExtensionReferences.FileName)%(_ResolvedAppExtensionReferences.Extension)"
		/>

		<!-- Delete any code signatures and dSYM dirs since they are now invalid -->
		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(_AppBundlePath)PlugIns\%(_ResolvedAppExtensionReferences.FileName)%(_ResolvedAppExtensionReferences.Extension)\_CodeSignature;
			$(_AppBundlePath)..\%(_ResolvedAppExtensionReferences.FileName)%(_ResolvedAppExtensionReferences.Extension).dSYM" />
	</Target>

	<Target Name="_ValidateAppBundle" Condition="'$(IsAppExtension)' == 'false' And '$(IsWatchApp)' == 'false'" DependsOnTargets="_DetectSdkLocations">
		<ValidateAppBundleTask
			Condition="'$(IsMacEnabled)' == 'true'"
			SessionId="$(BuildSessionId)"
			AppBundlePath="$(_AppBundlePath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
		/>
	</Target>

	<Target Name="_SeparateWatchAppReferences" BeforeTargets="AssignProjectConfiguration" Condition="'$(IsAppExtension)' == 'true' Or '$(OutputType)' == 'Exe'">
		<CreateItem Include="@(ProjectReference)" PreserveExistingMetadata="true" Condition="'%(Identity)' != '' And '%(ProjectReference.IsWatchApp)' == 'true'">
			<Output ItemName="_WatchAppReference" TaskParameter="Include" />
		</CreateItem>

		<ItemGroup>
			<ProjectReference Remove="@(_WatchAppReference)" />
		</ItemGroup>

		<!--<Warning Text="_SeparateWatchAppReferences: '@(_WatchAppReference)'"/>-->
	</Target>

	<Target Name="_AssignWatchAppConfiguration" Condition="'@(_WatchAppReference)' != ''">
		<!-- assign configs if building a solution file -->
		<AssignProjectConfiguration
			ProjectReferences = "@(_WatchAppReference)"
			SolutionConfigurationContents = "$(CurrentSolutionConfigurationContents)"
			Condition="'$(CurrentSolutionConfigurationContents)' != ''">

			<Output TaskParameter="AssignedProjects" ItemName="_WatchAppReferenceWithConfiguration"/>
		</AssignProjectConfiguration>

		<!-- Else, just -->
		<CreateItem Include="@(_WatchAppReference)" 
					Condition="'$(CurrentSolutionConfigurationContents)' == ''">
			<Output TaskParameter="Include" ItemName="_WatchAppReferenceWithConfiguration"/>
		</CreateItem>

		<!--<Warning Text="_AssignWatchAppConfiguration: '@(_WatchAppReferenceWithConfiguration)'"/>-->
	</Target>

	<!-- Split iOS Watch App projects into 2 lists
		_WatchAppReferenceWithConfigurationExistent: Projects existent on disk
		_WatchAppReferenceWithConfigurationNonExistent: Projects non-existent on disk -->
	<Target Name="_SplitWatchAppReferencesByExistent" DependsOnTargets="_AssignWatchAppConfiguration">
		<CreateItem Include="@(_WatchAppReferenceWithConfiguration)" Condition="'@(_WatchAppReferenceWithConfiguration)' != ''">
			<Output TaskParameter="Include" ItemName="_WatchAppReferenceWithConfigurationExistent" 
				Condition="Exists ('%(_WatchAppReferenceWithConfiguration.Identity)')"/>

			<Output TaskParameter="Include" ItemName="_WatchAppReferenceWithConfigurationNonExistent"
				Condition="!Exists ('%(_WatchAppReferenceWithConfiguration.Identity)')"/>
		</CreateItem>

		<!--<Warning Text="_SplitWatchAppReferencesByExistent: '@(_WatchAppReferenceWithConfigurationExistent)'"/>-->
	</Target>

	<Target Name="_ResolveWatchAppReferences" DependsOnTargets="_SplitWatchAppReferencesByExistent">
		<PropertyGroup>
			<!-- When building a .sln with msbuild, the dependent projects may not be built. So, always build
			     the referenced projects unless building from IDE. -->
			<_BuildReferencedExtensionProjects Condition="'$(BuildingInsideVisualStudio)' != 'true'">true</_BuildReferencedExtensionProjects>
		</PropertyGroup>

		<!-- If the referenced projects have already been built, then just get the target paths -->
		<MSBuild
			Projects="@(_WatchAppReferenceWithConfigurationExistent)"
			Targets="GetBundleTargetPath"
			Properties="%(_WatchAppReferenceWithConfigurationExistent.SetConfiguration); %(_WatchAppReferenceWithConfigurationExistent.SetPlatform)"
			Condition="'@(_WatchAppReferenceWithConfigurationExistent)' != '' and '$(_BuildReferencedExtensionProjects)' != 'true'">

			<Output TaskParameter="TargetOutputs" ItemName="_ResolvedWatchAppReferences" />
		</MSBuild>

		<!-- Build the referenced project if required -->
		<MSBuild
			Projects="@(_WatchAppReferenceWithConfigurationExistent)"
			Properties="%(_WatchAppReferenceWithConfigurationExistent.SetConfiguration); %(_WatchAppReferenceWithConfigurationExistent.SetPlatform)"
			Condition="'@(_WatchAppReferenceWithConfigurationExistent)' != '' and '$(_BuildReferencedExtensionProjects)' == 'true' ">

			<Output TaskParameter="TargetOutputs" ItemName="_ResolvedWatchAppReferences" />
		</MSBuild>

		<Warning Text="Referenced iOS Watch App Project %(_WatchAppReferenceWithConfigurationNonExistent.Identity) not found, ignoring."
			 Condition="'@(_WatchAppReferenceWithConfigurationNonExistent)' != ''"/>

		<PropertyGroup>
			<IsWatchExtension Condition="'$(IsAppExtension)' == 'true' And '@(_ResolvedWatchAppReferences)' != ''">True</IsWatchExtension>
		</PropertyGroup>
	</Target>

	<Target Name="_CopyWatchOS1AppsToBundle" Condition="'$(IsAppExtension)' == 'true'" DependsOnTargets="_ResolveWatchAppReferences">
		<Ditto
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ResolvedWatchAppReferences)' != '' And '%(_ResolvedWatchAppReferences.Identity)' != ''"
			ToolExe="$(DittoExe)"
			ToolPath="$(DittoPath)"
			Source="@(_ResolvedWatchAppReferences)"
			Destination="$(_AppBundlePath)%(_ResolvedWatchAppReferences.FileName)%(_ResolvedWatchAppReferences.Extension)"
		/>
	</Target>

	<Target Name="_CopyWatchOS2AppsToBundle" Condition="'$(OutputType)' == 'Exe'" DependsOnTargets="_ResolveWatchAppReferences">
		<Ditto
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ResolvedWatchAppReferences)' != '' And '%(_ResolvedWatchAppReferences.Identity)' != ''"
			ToolExe="$(DittoExe)"
			ToolPath="$(DittoPath)"
			Source="@(_ResolvedWatchAppReferences)"
			Destination="$(_AppBundlePath)Watch\%(_ResolvedWatchAppReferences.FileName)%(_ResolvedWatchAppReferences.Extension)"
		/>
	</Target>

	<Target Name="_CollectFrameworks" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_CompileToNative">
		<CollectFrameworks
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundlePath="$(_AppBundlePath)"
			>
			<Output TaskParameter="Frameworks" ItemName="_Frameworks"/>
		</CollectFrameworks>
	</Target>

	<!-- Note: Always codesign *.dylibs even for Simulator builds. We use $(_CanOutputAppBundle) because dylibs can exist in app extensions as well. -->
	<Target Name="_CodesignNativeLibraries" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_DetectSigningIdentity;_CompileToNative">

		<PropertyGroup>
			<_CodesignDisableTimestamp>False</_CodesignDisableTimestamp>
			<_CodesignDisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(MtouchDebug)' == 'true'">True</_CodesignDisableTimestamp>
			<_LibraryCodeSigningKey>$(_CodeSigningKey)</_LibraryCodeSigningKey>
			<_LibraryCodeSigningKey Condition="'$(_LibraryCodeSigningKey)' == ''">-</_LibraryCodeSigningKey>
		</PropertyGroup>

		<CodesignNativeLibraries
			Condition="'$(IsMacEnabled)' == 'true'"
			SessionId="$(BuildSessionId)"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			AppBundleDir="$(AppBundleDir)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)codesign"
			CodesignAllocate="$(_CodesignAllocate)"
			DisableTimestamp="$(_CodesignDisableTimestamp)"
			Keychain="$(CodesignKeychain)"
			SigningKey="$(_LibraryCodeSigningKey)"
			ExtraArgs="$(CodesignExtraArgs)"
			>
		</CodesignNativeLibraries>
	</Target>

	<Target Name="_CodesignFrameworks" Condition="'$(_CanOutputAppBundle)' == 'true' And '@(_Frameworks)' != ''" DependsOnTargets="_DetectSigningIdentity;_CollectFrameworks"
		Inputs="%(_Frameworks.Identity)" Outputs="$(DeviceSpecificIntermediateOutputPath)codesign\%(_Frameworks.Filename)%(_Frameworks.Extension)">

		<PropertyGroup>
			<_CodesignDisableTimestamp>False</_CodesignDisableTimestamp>
			<_CodesignDisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(MtouchDebug)' == 'true'">True</_CodesignDisableTimestamp>
			<_FrameworkCodeSigningKey>$(_CodeSigningKey)</_FrameworkCodeSigningKey>
			<_FrameworkCodeSigningKey Condition="'$(_FrameworkCodeSigningKey)' == ''">-</_FrameworkCodeSigningKey>
		</PropertyGroup>

		<Codesign
			Condition="'$(IsMacEnabled)' == 'true'"
			SessionId="$(BuildSessionId)"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			CodesignAllocate="$(_CodesignAllocate)"
			DisableTimestamp="$(_CodesignDisableTimestamp)"
			Keychain="$(CodesignKeychain)"
			Resources="@(_Frameworks)"
			SigningKey="$(_FrameworkCodeSigningKey)"
			ExtraArgs="$(CodesignExtraArgs)"
			>
		</Codesign>

		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(DeviceSpecificIntermediateOutputPath)codesign" />

		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AlwaysCreate="true"
			Files="$(DeviceSpecificIntermediateOutputPath)codesign\%(_Frameworks.Filename)%(_Frameworks.Extension)"
			>
			<Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
		</Touch>
	</Target>

	<Target Name="_ReadAppExtensionCodesignProperties">
		<ReadItemsFromFile File="%(_ResolvedAppExtensionReferences.Identity)\..\codesign.items" Condition="Exists('%(_ResolvedAppExtensionReferences.Identity)\..\codesign.items')">
			<Output TaskParameter="Items" ItemName="_AppExtensionCodesignProperties" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_CodesignAppExtensions" Condition="'$(_CanOutputAppBundle)' == 'true' And '@(_AppExtensionCodesignProperties)' != ''"
		DependsOnTargets="_DetectSigningIdentity;_ReadAppExtensionCodesignProperties"
		Inputs="$(_AppBundlePath)PlugIns\%(_AppExtensionCodesignProperties.Identity)\%(_AppExtensionCodesignProperties.NativeExecutable);%(_AppExtensionCodesignProperties.CodesignAppExtensionInputs)"
		Outputs="$(_AppBundlePath)PlugIns\%(_AppExtensionCodesignProperties.Identity)\_CodeSignature\CodeResources">

		<CodesignNativeLibraries
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '%(_AppExtensionCodesignProperties.LibrarySigningKey)' != ''"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			AppBundleDir="$(_AppBundlePath)PlugIns\%(_AppExtensionCodesignProperties.Identity)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)codesign\PlugIns\%(_AppExtensionCodesignProperties.Identity)"
			CodesignAllocate="%(_AppExtensionCodesignProperties.CodesignAllocate)"
			DisableTimestamp="%(_AppExtensionCodesignProperties.DisableTimestamp)"
			Keychain="%(_AppExtensionCodesignProperties.Keychain)"
			SigningKey="%(_AppExtensionCodesignProperties.LibrarySigningKey)"
			ExtraArgs="%(_AppExtensionCodesignProperties.ExtraArgs)"
			>
		</CodesignNativeLibraries>

		<Codesign
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '%(_AppExtensionCodesignProperties.SigningKey)' != ''"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			CodesignAllocate="%(_AppExtensionCodesignProperties.CodesignAllocate)"
			DisableTimestamp="%(_AppExtensionCodesignProperties.DisableTimestamp)"
			Keychain="%(_AppExtensionCodesignProperties.Keychain)"
			Entitlements="%(_AppExtensionCodesignProperties.Entitlements)"
			ResourceRules="%(_AppExtensionCodesignProperties.ResourceRules)"
			Resources="$(_AppBundlePath)PlugIns\%(_AppExtensionCodesignProperties.Identity)"
			SigningKey="%(_AppExtensionCodesignProperties.SigningKey)"
			ExtraArgs="%(_AppExtensionCodesignProperties.ExtraArgs)"
			>
		</Codesign>

		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And ('$(_CanOutputAppBundle)' == 'true' And '%(_AppExtensionCodesignProperties.SigningKey)' != '') And Exists ('$(AppBundleDir)\..\%(_AppExtensionCodesignProperties.Identity).dSYM\Contents\Info.plist')"
			Files="$(AppBundleDir)\..\%(_AppExtensionCodesignProperties.Identity).dSYM\Contents\Info.plist"
		/>
		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And Exists ('$(_AppBundlePath)PlugIns\%(_AppExtensionCodesignProperties.Identity)\_CodeSignature\CodeResources')"
			Files="$(_AppBundlePath)PlugIns\%(_AppExtensionCodesignProperties.Identity)\_CodeSignature\CodeResources"
		/>
	</Target>

	<Target Name="_PrepareCodesignAppExtension" Condition="'$(_CanOutputAppBundle)' == 'true' And '$(IsAppExtension)' == 'true' And '@(_ResolvedAppBundleExtensions)' == ''">
		<!-- For App Extensions, we delay running codesign until it has been copied into the main app bundle... -->
		<PropertyGroup>
			<_CompiledEntitlementsFullPath></_CompiledEntitlementsFullPath>
			<_ResourceRulesFullPath></_ResourceRulesFullPath>
		</PropertyGroup>

		<GetFullPath SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" RelativePath="$(AppBundleDir)">
			<Output TaskParameter="FullPath" PropertyName="_AppBundleFullPath" />
		</GetFullPath>

		<GetFullPath SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(_CompiledCodesignEntitlements)' != ''" RelativePath="$(_CompiledCodesignEntitlements)">
			<Output TaskParameter="FullPath" PropertyName="_CompiledEntitlementsFullPath" />
		</GetFullPath>

		<GetFullPath SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(_PreparedResourceRules)' != ''" RelativePath="$(_PreparedResourceRules)">
			<Output TaskParameter="FullPath" PropertyName="_ResourceRulesFullPath" />
		</GetFullPath>

		<GetFiles SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Path="$(_AppBundleFullPath)" Pattern="*.*" Option="AllDirectories">
			<Output TaskParameter="Files" ItemName="_AppExtensionBundleFiles" />
		</GetFiles>

		<PropertyGroup>
			<!-- [System.IO.Path]::GetFileName() is safe to use -->
			<_AppBundleFileName>$([System.IO.Path]::GetFileName('$(AppBundleDir)'))</_AppBundleFileName>
			<_NativeExecutableFileName>$([System.IO.Path]::GetFileName('$(_NativeExecutable)'))</_NativeExecutableFileName>

			<_CodesignDisableTimestamp>False</_CodesignDisableTimestamp>
			<_CodesignDisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(MtouchDebug)' == 'true'">True</_CodesignDisableTimestamp>

			<_CodesignAppExtensionInputs>@(_AppExtensionBundleFiles);$(_EntitlementsFullPath)</_CodesignAppExtensionInputs>

			<_LibrarySigningKey>$(_CodeSigningKey)</_LibrarySigningKey>
			<_LibrarySigningKey Condition="'$(_LibrarySigningKey)' == ''">-</_LibrarySigningKey>
		</PropertyGroup>

		<ItemGroup>
			<_AppExtensionCodesignProperties Remove="@(_AppExtensionCodesignProperties)" />

			<_AppExtensionCodesignProperties Include="$(_AppBundleFileName)">
				<CodesignAppExtensionInputs>$(_CodesignAppExtensionInputs)</CodesignAppExtensionInputs>
				<NativeExecutable>$(_NativeExecutableFileName)</NativeExecutable>
				<CodesignAllocate>$(_CodesignAllocate)</CodesignAllocate>
				<DisableTimestamp>$(_CodesignDisableTimestamp)</DisableTimestamp>
				<Entitlements>$(_CompiledEntitlementsFullPath)</Entitlements>
				<ResourceRules>$(_ResourceRulesFullPath)</ResourceRules>
				<Keychain>$(CodesignKeychain)</Keychain>
				<LibrarySigningKey>$(_LibrarySigningKey)</LibrarySigningKey>
				<SigningKey>$(_CodeSigningKey)</SigningKey>
				<ExtraArgs>$(CodesignExtraArgs)</ExtraArgs>
			</_AppExtensionCodesignProperties>
		</ItemGroup>

		<WriteItemsToFile
			Condition="'$(IsMacEnabled)' == 'true'"
			Items="@(_AppExtensionCodesignProperties)"
			ItemName="_AppExtensionCodesignProperties"
			File="$(DeviceSpecificOutputPath)codesign.items"
			IncludeMetadata="true"
			Overwrite="true"
		/>
	</Target>

	<Target Name="_CalculateCodesignAppBundleInputs" Condition="('$(_CanOutputAppBundle)' == 'true' And '$(_CodeSigningKey)' != '') And ('$(IsAppExtension)' == 'false' Or '@(_ResolvedAppExtensionReferences)' != '')">
		<ItemGroup>
			<_CodesignAppBundleInputs Include="$(_AppBundlePath)**\*.*" Exclude="$(_AppBundlePath)_CodeSignature\CodeResources" />
		</ItemGroup>
	</Target>

	<Target Name="_CodesignAppBundle" Condition="('$(_CanOutputAppBundle)' == 'true' And '$(_CodeSigningKey)' != '') And ('$(IsAppExtension)' == 'false' Or '@(_ResolvedAppExtensionReferences)' != '')" DependsOnTargets="$(_CodesignAppBundleDependsOn)"
		Inputs="@(_CodesignAppBundleInputs)" Outputs="$(_AppBundlePath)_CodeSignature\CodeResources">

		<PropertyGroup>
			<_CodesignDisableTimestamp>False</_CodesignDisableTimestamp>
			<_CodesignDisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(MtouchDebug)' == 'true'">True</_CodesignDisableTimestamp>
		</PropertyGroup>

		<Codesign
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			CodesignAllocate="$(_CodesignAllocate)"
			DisableTimestamp="$(_CodesignDisableTimestamp)"
			Keychain="$(CodesignKeychain)"
			Entitlements="$(_CompiledCodesignEntitlements)"
			ResourceRules="$(_PreparedResourceRules)"
			Resources="$(AppBundleDir)"
			SigningKey="$(_CodeSigningKey)"
			ExtraArgs="$(CodesignExtraArgs)"
			>
		</Codesign>

		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And Exists ('$(AppBundleDir).dSYM\Contents\Info.plist')"
			Files="$(AppBundleDir).dSYM\Contents\Info.plist"
		/>
		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And Exists ('$(_AppBundlePath)_CodeSignature\CodeResources')"
			Files="$(_AppBundlePath)_CodeSignature\CodeResources"
		/>
	</Target>

	<Target Name="_CodesignVerify" Condition="'$(_RequireCodeSigning)' == 'true' And ('$(IsAppExtension)' == 'false' Or '@(_ResolvedAppExtensionReferences)' != '')" DependsOnTargets="_CodesignAppBundle">
		<CodesignVerify
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ResolvedAppExtensionReferences)' != ''"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			CodesignAllocate="$(_CodesignAllocate)"
			Resource="$(_AppBundlePath)PlugIns\%(_ResolvedAppExtensionReferences.Filename)%(_ResolvedAppExtensionReferences.Extension)"
		>
		</CodesignVerify>

		<CodesignVerify
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			CodesignAllocate="$(_CodesignAllocate)"
			Resource="$(AppBundleDir)"
		>
		</CodesignVerify>
	</Target>

	<Target Name="_CoreCreateIpa" Condition="'$(BuildIpa)' == 'true'" DependsOnTargets="Codesign">
		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(DeviceSpecificIntermediateOutputPath)ipa" />

		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(DeviceSpecificIntermediateOutputPath)ipa\Payload" />

		<PropertyGroup>
			<_IpaAppBundleDir>$(DeviceSpecificIntermediateOutputPath)ipa\Payload\$(_AppBundleName).app\</_IpaAppBundleDir>
		</PropertyGroup>

		<!-- Clone the compiled app bundle into the IPA's Payload directory... -->
		<Ditto
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(DittoExe)"
			ToolPath="$(DittoPath)"
			Source="$(AppBundleDir)"
			Destination="$(_IpaAppBundleDir)"
		/>

		<FindWatchOS1AppExtensionBundle
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ResolvedAppExtensionReferences)' != ''"
			AppExtensionReferences="@(_ResolvedAppExtensionReferences)"
			>
			<Output TaskParameter="WatchOS1AppExtensionBundle" PropertyName="_WatchOS1AppExtensionBundle"/>
		</FindWatchOS1AppExtensionBundle>

		<Copy
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(_WatchOS1AppExtensionBundle)' != ''"
			SourceFiles="$(_WatchOS1AppExtensionBundle)\_WatchKitStub\WK"
			DestinationFolder="$(DeviceSpecificIntermediateOutputPath)ipa\WatchKitSupport"
		/>

		<FindWatchOS2AppBundle
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ResolvedWatchAppReferences)' != ''"
			WatchAppReferences="@(_ResolvedWatchAppReferences)"
			>
			<Output TaskParameter="WatchOS2AppBundle" PropertyName="_WatchOS2AppBundle"/>
		</FindWatchOS2AppBundle>

		<Copy
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(_WatchOS2AppBundle)' != ''"
			SourceFiles="$(_WatchOS2AppBundle)\_WatchKitStub\WK"
			DestinationFolder="$(DeviceSpecificIntermediateOutputPath)ipa\WatchKitSupport2"
		/>

		<CollectITunesSourceFiles
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			OutputPath="$(DeviceSpecificOutputPath)"
			>
			<Output TaskParameter="ITunesSourceFiles" ItemName="_ITunesSourceFile"/>
		</CollectITunesSourceFiles>

		<Copy
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ITunesSourceFile)' != ''"
			SourceFiles="@(_ITunesSourceFile)"
			DestinationFolder="$(DeviceSpecificIntermediateOutputPath)ipa"
		/>

		<ItemGroup>
			<_IpaPackageSource Include="$(DeviceSpecificIntermediateOutputPath)ipa\Payload" />
			<_IpaPackageSource Include="$(DeviceSpecificIntermediateOutputPath)ipa\WatchKitSupport" Condition="Exists ('$(DeviceSpecificIntermediateOutputPath)ipa\WatchKitSupport\WK')" />
			<_IpaPackageSource Include="$(DeviceSpecificIntermediateOutputPath)ipa\WatchKitSupport2" Condition="Exists ('$(DeviceSpecificIntermediateOutputPath)ipa\WatchKitSupport2\WK')" />
			<_IpaPackageSource Include="$(DeviceSpecificIntermediateOutputPath)ipa\iTunesMetadata.plist" Condition="'$(IpaIncludeArtwork)' == 'true' And Exists ('$(DeviceSpecificIntermediateOutputPath)ipa\iTunesMetadata.plist')" />
			<_IpaPackageSource Include="$(DeviceSpecificIntermediateOutputPath)ipa\iTunesArtwork@2x" Condition="'$(IpaIncludeArtwork)' == 'true' And Exists ('$(DeviceSpecificIntermediateOutputPath)ipa\iTunesArtwork@2x')" />
			<_IpaPackageSource Include="$(DeviceSpecificIntermediateOutputPath)ipa\iTunesArtwork" Condition="'$(IpaIncludeArtwork)' == 'true' And Exists ('$(DeviceSpecificIntermediateOutputPath)ipa\iTunesArtwork')" />
		</ItemGroup>

		<PropertyGroup>
			<!-- Calculate IpaPackageDir and IpaPackageName based on IpaPackagePath, if defined. -->
			<IpaPackageDir Condition="'$(IpaPackagePath)' != ''">$([System.Path]::GetDirectoryName('$(IpaPackagePath)'))</IpaPackageDir>
			<IpaPackageName Condition="'$(IpaPackagePath)' != ''">$([System.Path]::GetFileName('$(IpaPackagePath)'))</IpaPackageName>

			<!-- Calculate an IPA package directory path if not already defined by the developer. -->
			<!--<IpaPackageDir Condition="'$(IpaPackageDir)' == ''">$([System.Environment]::GetEnvironmentVariable('IPA_PACKAGE_DIR'))</IpaPackageDir>-->
			<IpaPackageDir Condition="'$(IpaPackageDir)' == ''">$(DeviceSpecificOutputPath)</IpaPackageDir>

			<!-- Calculate an IPA package name if not already defined by the developer. -->
			<!--<IpaPackageName Condition="'$(IpaPackageName)' == ''">$([System.Environment]::GetEnvironmentVariable('IPA_PACKAGE_NAME'))</IpaPackageName>-->
			<IpaPackageName Condition="'$(IpaPackageName)' != '' And !$(IpaPackageName.EndsWith ('.ipa', StringComparison.OrdinalIgnoreCase))">$(IpaPackageName).ipa</IpaPackageName>
			<IpaPackageName Condition="'$(IpaPackageName)' == ''">$(_AppBundleName).ipa</IpaPackageName>

			<!-- Calculate the full path of the IPA package if not already defined by the developer. -->
			<!--<IpaPackagePath Condition="'$(IpaPackagePath)' == ''">$([System.Environment]::GetEnvironmentVariable('IPA_PACKAGE_PATH'))</IpaPackagePath>-->
			<IpaPackagePath Condition="'$(IpaPackagePath)' == ''">$(IpaPackageDir)\$(IpaPackageName)</IpaPackagePath>
		</PropertyGroup>
	</Target>
	
	<Target Name="_PackageOnDemandResources" Condition="'$(BuildIpa)' == 'true' And '$(EnableOnDemandResources)' == 'true' And ('$(_DistributionType)' == 'AppStore' Or '$(_DistributionType)' == 'AdHoc')" >
		<PropertyGroup>
			<_PayloadDir>$(DeviceSpecificIntermediateOutputPath)ipa\Payload\</_PayloadDir>
			<_IpaAppBundleDir>$(_PayloadDir)$(_AppBundleName).app\</_IpaAppBundleDir>

			<_IntermediateODRDir Condition="'$(_DistributionType)' == 'AppStore'">$(_PayloadDir)OnDemandResources\</_IntermediateODRDir>
			<_IntermediateODRDir Condition="'$(_DistributionType)' == 'AdHoc' And '$(EmbedOnDemandResources)' == 'true'">$(_IpaAppBundleDir)OnDemandResources\</_IntermediateODRDir>
			<_IntermediateODRDir Condition="'$(_DistributionType)' == 'AdHoc' And '$(EmbedOnDemandResources)' == 'false'">$(DeviceSpecificIntermediateOutputPath)OnDemandResourcesPackage\OnDemandResources\</_IntermediateODRDir>

			<OnDemandResourcesUrl Condition="'$(OnDemandResourcesUrl)' == '' And '$(_DistributionType)' == 'AdHoc' And '$(EmbedOnDemandResources)' == 'true'">OnDemandResources</OnDemandResourcesUrl>

			<IsStreamable>false</IsStreamable>
			<IsStreamable Condition="'$(EmbedOnDemandResources)' == 'false'">true</IsStreamable>

			<_CodesignDisableTimestamp>False</_CodesignDisableTimestamp>
			<_CodesignDisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(MtouchDebug)' == 'true'">True</_CodesignDisableTimestamp>
		</PropertyGroup>
		
		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(_IntermediateODRDir)" />
		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And Exists('$(DeviceSpecificOutputPath)OnDemandResources\')" Directories="$(_IntermediateODRDir)" />

		<!-- Clone the compiled assetpack bundle... -->
		<Ditto
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And Exists('$(DeviceSpecificOutputPath)OnDemandResources\')"
			ToolExe="$(DittoExe)"
			ToolPath="$(DittoPath)"
			Source="$(DeviceSpecificOutputPath)OnDemandResources\"
			Destination="$(_IntermediateODRDir)"
			/>

		<!-- Look for the *.assetpack folders in the ODR folder -->
		<CollectAssetPacks
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And Exists('$(_IntermediateODRDir)')"
			OnDemandResourcesPath="$(_IntermediateODRDir)"
			>

			<Output TaskParameter="AssetPacks" ItemName="_AssetPack"/>
		</CollectAssetPacks>

		<ItemGroup>
			<_AssetPack>
				<_DirectoryName>$([System.IO.Path]::GetDirectoryName('%(Identity)'))</_DirectoryName>
			</_AssetPack>
			<_AssetPack>
				<DirectoryName>$([System.IO.Path]::GetFileName('%(_AssetPack._DirectoryName)'))</DirectoryName>
			</_AssetPack>
		</ItemGroup>

		<!-- Sign assetpacks -->
		<Codesign
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_AssetPack)' != '' And '$(_DistributionType)' == 'AppStore'"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			CodesignAllocate="$(_CodesignAllocate)"
			DisableTimestamp="$(_CodesignDisableTimestamp)"
			Keychain="$(CodesignKeychain)"
			Entitlements="$(_CompiledCodesignEntitlements)"
			Resources="@(_AssetPack)"
			SigningKey="$(_CodeSigningKey)"
			ExtraArgs="$(CodesignExtraArgs)"
			>
		</Codesign>

		<WriteAssetPackManifest
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(_DistributionType)' == 'AdHoc' And Exists('$(_IntermediateODRDir)')"
			TemplatePath="$(_IpaAppBundleDir)AssetPackManifestTemplate.plist"
			OutputFile="$(_IpaAppBundleDir)AssetPackManifest.plist"
			OnDemandResourceUrl="$(OnDemandResourcesUrl)"
			IsStreamable="$(IsStreamable)"
			/>

		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(_DistributionType)' == 'AdHoc' And Exists('$(_IntermediateODRDir)')" Files="$(_IpaAppBundleDir)AssetPackManifestTemplate.plist" />

		<!-- Re-sign app bundle if anything changed inside of it -->
		<Codesign
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(_DistributionType)' == 'AdHoc' And Exists('$(_IntermediateODRDir)')"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			CodesignAllocate="$(_CodesignAllocate)"
			DisableTimestamp="$(_CodesignDisableTimestamp)"
			Keychain="$(CodesignKeychain)"
			Entitlements="$(_CompiledCodesignEntitlements)"
			ResourceRules="$(_PreparedResourceRules)"
			Resources="$(_IpaAppBundleDir)"
			SigningKey="$(_CodeSigningKey)"
			ExtraArgs="$(CodesignExtraArgs)"
			/>

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(EmbedOnDemandResources)' == 'false'" Directories="$(IpaPackageDir)\OnDemandResources\" />
		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(EmbedOnDemandResources)' == 'false'" Directories="$(IpaPackageDir)\OnDemandResources\" />

		<CreateAssetPack
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(EmbedOnDemandResources)' == 'false'"
			ToolExe="$(ZipExe)"
			ToolPath="$(ZipPath)"
			Source="%(_AssetPack.Identity)"
			OutputFile="$(IpaPackageDir)OnDemandResources\%(_AssetPack.DirectoryName)"
			/>

		<Copy
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(EmbedOnDemandResources)' == 'false'"
			SourceFiles="$(_IpaAppBundleDir)AssetPackManifest.plist"
			DestinationFolder="$(IpaPackageDir)\OnDemandResources\"
			/>
	</Target>

	<Target Name="_ZipIpa" Condition="'$(BuildIpa)' == 'true'">
		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(IpaPackageDir)" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="$(IpaPackagePath)" />

		<Zip
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(ZipExe)"
			ToolPath="$(ZipPath)"
			Recursive="true"
			Symlinks="true"
			Sources="@(_IpaPackageSource)"
			OutputFile="$(IpaPackagePath)"
			WorkingDirectory="$(DeviceSpecificIntermediateOutputPath)ipa"
			>
			<Output TaskParameter="OutputFile" ItemName="FileWrites" />
		</Zip>
	</Target>

	<Target Name="_CoreArchive" Condition="'$(ArchiveOnBuild)' == 'true'" DependsOnTargets="Codesign">
		<CollectITunesSourceFiles
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ITunesSourceFile)' == ''"
			OutputPath="$(DeviceSpecificOutputPath)"
			>
			<Output TaskParameter="ITunesSourceFiles" PropertyName="_ITunesSourceFile"/>
		</CollectITunesSourceFiles>

		<Archive
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			AppExtensionReferences="@(_ResolvedAppExtensionReferences)"
			InsightsApiKey="$(XamarinInsightsApiKey)"
			ITunesSourceFiles="@(_ITunesSourceFile)"
			OutputPath="$(DeviceSpecificOutputPath)"
			ProjectName="$(MSBuildProjectName)"
			ProjectGuid="$(ProjectGuid)"
			ProjectTypeGuids="$(ProjectTypeGuids)"
			SolutionPath="$(SolutionPath)"
			SigningKey="$(_CodeSigningKey)"
			WatchAppReferences="@(_ResolvedWatchAppReferences)"
			>
			<Output TaskParameter="ArchiveDir" PropertyName="ArchiveDir"/>
		</Archive>
	</Target>

	<Import Project="$(MSBuildThisFileDirectory)Xamarin.iOS.NativeReference.Stubs.targets" />

	<Import Project="$(MSBuildThisFileDirectory)$(MSBuildThisFileName).After.targets"
			Condition="Exists('$(MSBuildThisFileDirectory)$(MSBuildThisFileName).After.targets')"/>

</Project>
